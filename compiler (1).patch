diff --git a/compiler.patch b/compiler.patch
new file mode 100644
index 0000000..e69de29
diff --git a/reader.ml b/reader.ml
index c4fd6b2..5a1b8a5 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,6 +1,7 @@
 
 #use "pc.ml";;
-
+module Sets = Set.Make(String);;
+open PC;;
 exception X_not_yet_implemented;;
 exception X_this_should_not_happen;;
   
@@ -37,16 +38,448 @@ module Reader: sig
   val read_sexpr : string -> sexpr
   val read_sexprs : string -> sexpr list
 end
-= struct
+= struct 
+  open PC;;
 let normalize_scheme_symbol str =
   let s = string_to_list str in
   if (andmap
 	(fun ch -> (ch = (lowercase_ascii ch)))
 	s) then str
   else Printf.sprintf "|%s|" str;;
-
-let read_sexpr string = raise X_not_yet_implemented ;;
+  (* let read_sexpr string =  raise X_not_yet_implemented;;
+  (* let ((e,empty), s) = ((caten  _sexp_ nt_end_of_input) (string_to_list string)) in
+  e;; *)
 
 let read_sexprs string = raise X_not_yet_implemented;;
+  (* let ((a,(e,empty)), s) = (caten  _garbage_ (caten (star _sexp_) nt_end_of_input) (string_to_list string)) in
+  e;; *)
+end;; struct Reader *)
+
+let nt_whitespace = const (fun ch -> ch <= ' ');;
+
+let make_paired nt_left nt_right nt =
+  let nt = caten nt_left nt in
+  let nt = pack nt (function (_ , e)-> e) in
+  let nt = caten nt nt_right in
+  let nt = pack nt (function (e,_) ->e) in
+  nt;;
+
+let rec _sexp_ s= 
+  (make_paired _garbage_
+               _garbage_
+   (disj_list[_bool_;
+             _char_;
+             _ScieFloat_;
+             _float_;
+             _radixFloat_;
+             _ScieInteger_;
+             _integer_;
+             _radixInt_;
+             _string_;
+             _symbol_;
+             _nil_;
+             _list_;
+             _Dottedlist_;
+             _Quoted_;
+             _QQuoted_;
+             _UnquotedSpliced_;
+             _unquote_;
+             _taggedExpr_])) s
+
+and _bool_ s=
+  pack (disj (word_ci "#T")
+             (word_ci "#F"))
+              (fun (lst) ->
+                match lst with
+                |['#';'t'] -> Bool true
+                |['#';'T'] -> Bool true
+                |['#';'f'] -> Bool false
+                |['#';'F'] -> Bool false
+                |_ -> raise  X_this_should_not_happen) s
+              
+
+
+and _charprefix_ s=
+  word "#\\" s
+
+and _VisibleSimpleChar_ s=
+  pack (diff nt_any nt_whitespace)
+        (fun e -> Char e) s
+
+and _NamedChar_ s=
+  pack (disj_list [word_ci "newline";
+                   word_ci "nul";
+                   word_ci "page";
+                   word_ci "return";
+                   word_ci "space";
+                   word_ci "tab"])
+              (fun (lst) ->
+                let str = String.lowercase_ascii (list_to_string (lst)) in
+                match str with
+                | "newline" -> Char (Char.chr 10)
+                | "nul" -> Char (Char.chr 0)
+                | "tab" -> Char (Char.chr 9)
+                | "space" -> Char (Char.chr 32)
+                | "return" -> Char (Char.chr 13)
+                | "page" ->  Char (Char.chr 12)
+                |_ -> raise X_this_should_not_happen) s
+
+
+and _char_ s=
+  pack (caten _charprefix_ 
+       (disj _NamedChar_ _VisibleSimpleChar_ ))
+       (fun (e,es)-> es) s
+
+
+and _digit_ s= range '0' '9' s
+
+(*to check if negative value should be in brackets -> (-12)*)
+(*****************************************************************************************************************************************************************************)
+and op s= pack (maybe (disj (char '+') (char '-')))
+        (fun e ->
+          match e with 
+          | None -> '+'
+          | Some n-> n) s
+
+
+and _natural_ s=
+    not_followed_by (plus (_digit_)) 
+                     (diff 
+                     (diff nt_any (disj _digit_ nt_whitespace))
+                                  (disj (char ';') 
+                                  (disj (char '#') (char ')')))) s
+
+and _integer_ s=
+  pack (caten op _natural_)
+        (fun (e,es) ->
+        let num = int_of_string (list_to_string (es)) in
+        if e = '-' then Number (Int (-1*num))
+        else Number (Int num)) s
+
+and dot s=
+  pack (char '.')
+        (fun e -> Char.escaped e) s
+
+(* this kind of natural lets '.' after its start*)
+and _floatnatural_ s=
+    not_followed_by (plus (_digit_)) 
+                     (diff nt_any (disj_list [_digit_ ;
+                                              nt_whitespace ;
+                                              (char '.')])) s
+and _float_ s=
+  pack (caten (caten (caten 
+                op 
+                _floatnatural_) 
+                dot) 
+                _natural_) 
+        (fun (((o,i),d),f)->
+          let num = float_of_string (list_to_string (i)^d^list_to_string(f)) in 
+          if o='-' then Number (Float (-1.0 *. num))
+          else Number (Float num)) s
+
+and _StringMetaChar_ s =
+  pack (disj_list      [(caten (char '\\') (char_ci '\\'));
+                        (caten (char '\\') (char_ci '\"'));
+                        (caten (char '\\') (char_ci 't')) ;
+                        (caten (char '\\') (char_ci 'f')) ;
+                        (caten (char '\\') (char_ci 'n')) ;
+                        (caten (char '\\') (char_ci 'r')) ])
+        (fun (e,es)-> match lowercase_ascii es with
+        | '\\' -> "\\" 
+        | '\"' -> "\"" 
+        | 't'  -> "\t"
+        | 'f'  -> "\012" (*Char.escaped (char_of_int 12) (*to check wtf*)*)
+        | 'n'  -> "\n"
+        | 'r'  -> "\r"
+        | _ -> raise X_this_should_not_happen) s
+
+and _StringLiteralChar_ s =
+  let nt = (disj (char '\\') (char '\"'))  in (*char list->char * char list*)
+  let nt = (diff nt_any nt) in
+  pack nt (fun (e)-> String.make 1 e) s 
+
+and _string_ s  =
+  let nt= (star 
+          (disj 
+           _StringMetaChar_ _StringLiteralChar_ )) in
+  let nt= (make_paired (char '\"')
+               (char '\"')
+                nt) in 
+  pack nt (fun (lst)-> 
+    String (List.fold_right (fun e es -> e^es) lst ""))  s
+    
+and _SymbolChar_ s = 
+  disj_list [_digit_;
+             (range 'a' 'z');
+             (range 'A' 'Z');
+             (one_of "!$^*-_=+><?/:")] s
+
+and _symbol_ s =
+  pack (plus _SymbolChar_)
+        (fun lst -> 
+        Symbol (String.lowercase_ascii(List.fold_right (fun e es -> (Char.escaped e)^es) lst ""))) s
+
+
+and _linecomment_  s = (*to do*) 
+  let nt = (disj (char '\n') 
+                 (pack
+                 nt_end_of_input
+                 (fun e-> '\n'))) in
+  let nt=caten (caten (char ';')  (star (diff nt_any nt))) nt in 
+  pack nt (fun _ -> '\n') s
+
+ and _sexprcomment_ s = 
+   let nt = (pack 
+              (caten (word "#;") _sexp_)
+              (fun _ -> '\n')) in
+   let nt= (disj nt
+                 (pack 
+                 (caten (caten (word "#;") _sexprcomment_) _sexp_)
+                 (fun _ -> '\n'))) in
+   pack nt (fun _ -> '\n') s 
+(*
+and _skippable_ s =
+let nt = disj _whitespace_skip_ _sexprcomment_ in
+let nt = disj nt _linecomment_ in
+let nt = star nt in
+nt s *)
+(*
+and _whitespace_skip_ s =
+pack nt_whitespace (fun _ -> ()) s *) 
+(*
+and let nt_sexpr s = 
+let nt = make_paired _skippable_ _skippable_ disj_list
+[_bool_,_char_,_float_,_integer_,_string_,_symbol_,_list_,_Dottedlist_,_Quoted_,quasiquote,_unquote_,_UnquotedSpliced_,_taggedExpr_]
+in pack nt (fun (s,r) -> s) *)
+
+
+and _comment_ s=
+let nt = (disj _linecomment_ _sexprcomment_ ) in
+nt s
+
+and _garbage_ s=
+  pack (star (disj nt_whitespace _comment_))
+       (fun e-> None) s
+
+
+and _nil_ s= 
+  (pack (make_paired (char '(') 
+                    (char ')') 
+                    _garbage_)
+        (fun e-> Nil)) s
+
+and _list_ s=
+  let nt= (caten (caten _garbage_ _sexp_) _garbage_) in
+  let nt= (pack nt
+              (fun ((a,b),c) -> b)) in
+  let nt=make_paired (char '(') 
+                     (char ')') 
+                     (star nt) in 
+  (pack nt
+        (fun e-> 
+        List.fold_right
+        (fun a b -> Pair (a , b))
+        e
+        Nil)) s 
   
+and _Dottedlist_ s=
+  let nt= (caten (caten _garbage_ _sexp_) _garbage_) in
+  let nt= (pack nt
+              (fun ((a,b),c) -> b)) in
+  let nt= caten (caten(plus nt) (char '.')) nt in 
+  let nt=make_paired (char '(') 
+                     (char ')') 
+                     nt in 
+  (pack nt
+        (fun ((e,f),g)-> 
+        List.fold_right
+        (fun a b -> Pair (a , b))
+        e
+        g)) s
+and _qoutePacker_ s=
+  pack _sexp_
+       (fun e-> Pair (e,Nil)) s
+and _Quoted_ s=
+  let nt= caten  (pack
+                 (char (char_of_int 39))
+                 (fun e -> Symbol "quote"))
+                 _qoutePacker_ in
+  pack nt
+    (fun (a,b)->Pair (a,b)) s
+
+and _QQuoted_ s=
+  let nt= caten  (pack
+                 (char '`')
+                 (fun e -> Symbol "quasiquote"))
+                 _qoutePacker_ in
+  pack nt
+    (fun (a,b)->Pair (a,b)) s
+
+and _UnquotedSpliced_ s=
+  let nt= caten  (pack
+                 (word ",@")
+                 (fun e -> Symbol "unquote-splicing"))
+                 _qoutePacker_ in
+  pack nt
+    (fun (a,b)->Pair (a,b)) s    
+    
+and _unquote_ s=
+  let nt= caten  (pack
+                 (char ',')
+                 (fun e -> Symbol "unquote"))
+                 _qoutePacker_ in
+  pack nt
+    (fun (a,b)->Pair (a,b)) s 
+and _ScieNatural_ s=
+    not_followed_by (plus (_digit_)) 
+                     (diff 
+                     (diff nt_any (disj _digit_ nt_whitespace))
+                     (char_ci 'e')) s
+and _ScieInteger_ s=
+  let nt=(caten _ScieNatural_ (char_ci 'e'))  in 
+  let nt= (caten nt (caten op _natural_)) in 
+  let nt=pack nt
+        (fun (((num),e),(op2,exp)) ->
+        if op2== '-' then
+          float_of_string (list_to_string (List.append (List.append num [e]) (List.append [op2] exp)))
+        else
+          float_of_string (list_to_string (List.append (List.append num [e]) exp)))  in
+  pack (caten op nt) 
+        (fun (op,num)->
+        if op = '-' then Number (Float (-1.0 *. num)) 
+        else Number (Float num)) s 
+        
+and _ScieFloat_ s=
+  let nt=(caten (caten dot _ScieNatural_) (char_ci 'e'))  in 
+  let nt= (caten _floatnatural_) nt in
+  let nt= (caten nt (caten op _natural_)) in 
+  let nt=pack nt
+        (fun ((num,((dot,rest),e)),(op2,exp)) ->
+        let num = (List.append (List.append num ['.']) rest) in
+        if op2== '-' then
+          float_of_string (list_to_string (List.append (List.append num [e]) (List.append [op2] exp)))
+        else
+          float_of_string (list_to_string (List.append (List.append num [e]) exp)))  in
+  pack (caten op nt) 
+        (fun (op,num)->
+        if op = '-' then Number (Float (-1.0 *. num)) 
+        else Number (Float num)) s 
+      
+and _radixInt_ s=
+  let nt =caten (char '#') (caten (plus _digit_) (char_ci 'r')) in
+  let nt= (caten nt (caten op _radixTransformer_))  in 
+  pack (not_followed_by nt dot)
+    (fun ((tag,(base,r)),(op,digits))->
+    let num=(List.fold_left
+    (fun es e-> es*(int_of_string (list_to_string (base)))+e)
+    0 digits) in
+    if op = '-' then Number (Int (-1 * num)) 
+    else Number (Int num)) s 
+
+and _radixFloat_ s=
+  let nt =caten (char '#') (caten (plus _digit_) (char_ci 'r')) in
+  let nt= (caten nt (caten op _radixTransformerFloat_))  in 
+  let nt= (caten nt (caten dot _radixTransformerFloat_)) in 
+  pack nt
+    (fun (((tag,(base,r)),(op,digits)),(dot,afterDot))->
+    let num=(List.fold_left
+    (fun es e-> es*.(float_of_string (list_to_string (base)))+.e)
+    0.0 digits) in
+    let num=num +. 
+    (List.fold_right
+    (fun e es-> (es+.e)/. (float_of_string (list_to_string (base))))
+    afterDot 0.0) in
+    if op = '-' then Number (Float (-1.0 *. num)) 
+    else Number (Float num)) s 
+
+and _radixTransformer_ s=
+  pack (star (disj_list [_digit_;
+                        (range 'a' 'z');
+                        (range 'A' 'Z')]))
+       (fun e->
+       (List.fold_right 
+       (fun e es -> 
+       (_charToInt_ e):: es)
+        e []))  s
+
+and _radixTransformerFloat_ s=
+  pack _radixTransformer_
+       (fun e->
+       (List.fold_right 
+       (fun e es -> 
+       (float_of_int e):: es)
+        e []))  s
+
+and _charToInt_ s=
+  if ('A' <= s && s <= 'Z') then
+    (10 + int_of_char s - int_of_char 'A') 
+  else 
+  if ('a' <= s && s <= 'z') then
+  (10 + int_of_char s - int_of_char 'a') 
+  else  int_of_char s - int_of_char '0' 
+
+and _tag_ s=
+  caten (char '#') 
+        (make_paired (char '{')
+        (char '}')
+        _symbol_) s
+
+and _taggedExprParse_ s=
+  caten _tag_ 
+        (maybe
+        (caten 
+        (make_paired
+        _garbage_
+        _garbage_
+        (char '='))
+        _sexp_)) s
+
+and _taggedExpr_ s=
+  (pack _taggedExprParse_
+         (fun ((tag,symbola),equal) ->
+            match symbola with
+            | Symbol a ->
+            (match equal with
+            | None -> TagRef a
+            | Some (n, sexp)->
+            match (_sexpContain_ sexp a) with
+            | true -> raise X_this_should_not_happen
+            | false -> TaggedSexpr(a, sexp))
+            | _ ->raise X_this_should_not_happen)) s 
+      
+and _sexpContain_ exp a=
+  match exp with
+  | Pair(car, cdr) -> (_sexpContain_ car a) || (_sexpContain_ cdr a)
+  | TaggedSexpr (car , cdr) -> car=a || (_sexpContain_ cdr a)
+  | _ -> false ;;
+
+let read_sexprs2 string = 
+  let ((a,(e,empty)), s) = (caten  _garbage_ (caten (star _sexp_) nt_end_of_input) (string_to_list string)) in
+  e;;
+(* test_string _StringLiteralChar_ "' ";; *)
+(* test_string _sexp_ "a \"  a  s";;
+(_sexpContain_ ((Pair (Symbol "a"), Nil))) ;; *)
+
+
+ (* read_sexprs2 "3;";;  *)
+(* test_string _nil_ "()";; *)
+
+let checkTags s = 
+let set = ref Sets.empty in
+let rec  check x = match x with
+| Pair(a,b) -> (check a) || (check b) 
+|  TaggedSexpr(a, b) -> if Sets.exists (fun x -> x = a ) !set then true 
+  else (set := Sets.add a !set ; check b) 
+| _ -> false in check s
+
+
+let read_sexpr string =  
+let ((e,empty), s) = ((caten  _sexp_ nt_end_of_input) (string_to_list string)) in
+ if checkTags e then raise X_this_should_not_happen else e;;
+
+
+let read_sexprs string = 
+let ((a,(e,empty)), s) = (caten  _garbage_ (caten (star (pack _sexp_ (function (e) -> if checkTags e then raise X_this_should_not_happen else e))) nt_end_of_input) (string_to_list string)) in
+e;;
 end;; (* struct Reader *)
+
diff --git a/readme.txt b/readme.txt
index e69de29..134d66d 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,4 @@
+Michael Atias 205689905
+Chen Rejwan 312501323
+
+I (We) assert that the work we submitted is 100% our own. We have not received anypart from any other student in the class, nor have we give parts of it for use to others.Nor have we used code from other sources: Courses taught previously at this university,courses taught at other universities, various bits of code found on the Internet, etc.We realize that should our code be found to contain code from other sources, that aformal case shall be opened against us withva’adat mishma’at, in pursuit of disciplinaryaction.
\ No newline at end of file
diff --git a/structure_test.sh b/structure_test.sh
new file mode 100644
index 0000000..3fe13ed
--- /dev/null
+++ b/structure_test.sh
@@ -0,0 +1,109 @@
+#!/bin/bash
+
+BASE_DIR=$(pwd)
+PATCH=$1
+AUTHENTICITY=readme.txt
+CODE=tag-parser.ml
+STATEMENT="realize that should our code be found to contain code from other sources, that a formal case shall be opened against"
+PROBLEM=0
+GIT_REPO="https://www.cs.bgu.ac.il/~comp201/compiler"
+LOCAL_REPO=compiler
+TMP_FOLDER=$(mktemp -d)
+OCAML_TMP_FILE=struct_test.ml
+OCAML_TYPE_TEST="#use \"tag-parser.ml\";;
+(Const(Void): expr);;
+(Const(Sexpr(Nil)): expr);;
+(If(Const(Void),Const(Void),Const(Void)): expr);;
+(Var \"Asdas\" : expr);;
+(Seq [Const(Void)] : expr);;
+(Set (Const(Void), Const(Void)) : expr);;
+(Def (Const(Void), Const(Void)) : expr);;
+(Or [Const(Void)] : expr);;
+(LambdaSimple([\"Asdas\"],Seq ([Const(Void)])) : expr);;
+(LambdaOpt([\"Asdas\"],\"Asdas\",(Seq [Const(Void)])) : expr);;
+(Applic(Const(Void),[Const(Void)]));;"
+OCAML_SIG_TEST="#use \"tag-parser.ml\";;
+try
+  ((Tag_Parser.tag_parse_expression (Number(Int 1))):expr)
+with 
+| X_not_yet_implemented -> print_string \"Warning: Your submission is missing an implementation for Tag_Parser.tag_parse_expression!\n\"; Const(Void)
+| PC.X_no_match -> Const(Void)
+| X_syntax_error -> Const(Void);;
+
+try
+  ((Tag_Parser.tag_parse_expressions [Number(Int(1))]) : expr list)
+with 
+| X_not_yet_implemented -> print_string \"Warning: Your submission is missing an implementation for Tag_Parser.tag_parse_expressions!\n\";  [Const(Void)]
+| PC.X_no_match -> [Const(Void)]
+| X_syntax_error -> [Const(Void)];;"
+
+cleanup () {
+    #echo "cleaning up temporary files and exiting."
+    rm -rf $TMP_FOLDER
+}
+
+if [ $# -lt 1 ]; then
+    PATCH="compiler/compiler.patch" 
+fi
+
+if ! [ -f $PATCH ]; then
+    echo "ERROR: The patch file '$PATCH' cannot be found. Please provide the relative path filename to your patch file."
+    exit 2
+fi
+
+cd $TMP_FOLDER
+git clone -q $GIT_REPO
+if [ "$?" -ne 0 ]; then
+    echo "ERROR: There was a problem creating a temporary clone of the project repository. There might be a problem with your network connection. The structure test cannot be completed."
+    cleanup
+    exit 2
+fi
+
+cd $LOCAL_REPO
+git apply --ignore-whitespace --whitespace=nowarn $BASE_DIR/$PATCH
+if [ "$?" -ne 0 ]; then
+    echo "ERROR: The contents of your patch file are invalid and git cannot apply it. The structure test cannot be completed."
+    cleanup
+    exit 2
+fi
+
+
+if ! [ -f $AUTHENTICITY ]; then
+    echo "ERROR: Your submission is missing the authenticity statement file ($AUTHENTICITY)."
+    PROBLEM=1
+else 
+    ID=$(egrep -e '[0-9]{7,10}' $AUTHENTICITY)
+    STMNT=$(cat $AUTHENTICITY | tr -d [:space:] | grep -i "$(echo "$STATEMENT" | tr -d [:space:])")
+
+    if [ -z "$ID" ] || [ -z "$STMNT" ] ; then
+	echo "ERROR: Your authenticity statement (in $AUTHENTICITY) is incomplete."
+	PROBLEM=1
+    fi
+fi
+
+if ! [ -f $CODE ]; then
+    echo "ERROR: Your submission is missing the required code file: $CODE."
+    PROBLEM=1
+fi
+
+echo $OCAML_TYPE_TEST > $OCAML_TMP_FILE && ocaml $OCAML_TMP_FILE 2> /dev/null
+if [ $? -ne 0 ]; then
+    echo "ERROR: Your OCaml code contains invalid changes to the expr and/or constant types."
+    PROBLEM=1
+fi
+
+echo $OCAML_SIG_TEST > $OCAML_TMP_FILE && ocaml $OCAML_TMP_FILE 2> /dev/null
+if [ $? -ne 0 ]; then
+    echo "ERROR: Your OCaml code contains invalid changes to the signatures of the Tag_Parser module."
+    PROBLEM=1
+fi
+
+if [ $PROBLEM -ne 0 ]; then
+    echo "!!! Your submission is invalid. Please correct the problems and try again. !!!"
+else 
+    echo "Your submission passed the structure test.
+This does not mean that your assignment is correct, only that we can test it properly."
+fi
+
+cleanup
+exit $PROBLEM
\ No newline at end of file
diff --git a/tag-parser.ml b/tag-parser.ml
index 712f408..980687e 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -59,9 +59,212 @@ let reserved_word_list =
 
 (* work on the tag parser starts here *)
 
-let tag_parse_expression sexpr = raise X_not_yet_implemented;;
+(* let tag_parse_expression sexpr = raise X_not_yet_implemented;;
 
 let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
+end;; 
+ *)
 
+let reserved_word_list =
+  ["and"; "begin"; "cond"; "define"; "else";
+   "if"; "lambda"; "let"; "let*"; "letrec"; "or";
+   "quasiquote"; "quote"; "set!"; "unquote";
+   "unquote-splicing"];;  
+let rec tag_parse= function
+  | String(x) -> Const(Sexpr(String(x)))
+  | Char(x) -> Const(Sexpr(Char(x)))
+  | Bool(x) -> Const(Sexpr(Bool(x)))
+  | Number(x) -> Const(Sexpr(Number(x)))
+  | Nil -> Const(Sexpr(Nil))
+  | TagRef(x) -> Const(Sexpr(TagRef(x)))
+  | TaggedSexpr(x,y) -> (_parseTagExp_ (TaggedSexpr(x,y)))
+  |Pair(Symbol("define"),Pair(Pair(Symbol a,params),body)) -> tag_parse (mit_def a params body)
+  | Pair(Symbol("and"),x) -> tag_parse (recAnd x)
+  |Pair(Symbol("cond"),rest) -> tag_parse(condrec rest)
+  | Pair(Symbol("quote"), Pair(x, Nil)) -> Const(Sexpr(x))
+  | Pair(Symbol("if"), Pair(test, Pair(dit, Pair(dif, Nil)))) -> If(tag_parse test, tag_parse dit, tag_parse dif)
+  | Pair(Symbol("if"), Pair(test, Pair(dit, Nil))) -> If(tag_parse test, tag_parse dit, Const(Void))
+  | Pair(Symbol("lambda"), x) -> _lambda_ (Pair(Symbol("lambda"), x))
+  | Pair(Symbol("or"), Nil)->(Const (Sexpr (Bool false)))
+  | Pair(Symbol("or"), Pair(x,Nil))-> tag_parse x
+  | Pair(Symbol("or"), x) -> Or (List.map (fun a-> (tag_parse a)) (_schemeToOcamlList_ x))
+  | Pair(Symbol("define"), Pair(x,Nil)) -> Def (tag_parse x, Const Void)
+  | Pair(Symbol("define"), Pair(x,Pair(y,Nil))) -> Def (tag_parse x, tag_parse y)
+  | Pair(Symbol("set!"), Pair(x,Pair(y,Nil))) -> Set (tag_parse x, tag_parse y)
+  | Pair(Symbol("begin"), x) -> _seq_ (_schemeToOcamlList_ x)
+  | Pair(Symbol("quasiquote"), Pair(Pair(Symbol("unquote-splicing"), Pair(x,Nil)),Nil)) ->  raise X_syntax_error
+  | Pair(Symbol("quasiquote"), Pair(x,Nil)) -> (tag_parse (_quasiQuote_ x))
+  | Pair(Symbol("let"),x)-> _let_ x
+  | Pair(Symbol("let*"),x)->  tag_parse (_letStar_ x)
+  | Pair(Symbol("letrec"),x)->  tag_parse (_letRec_ x)
+  | Pair(x,y) -> Applic ((tag_parse x), (List.map (fun a-> (tag_parse a)) (_schemeToOcamlList_ y)))
+  | Symbol(x) -> (_parseVar_ (Symbol(x)))
+  
+
+and _parseTagExp_ = function
+  | TaggedSexpr (x, Pair (Symbol "quote", Pair(y,Nil))) -> Const(Sexpr(TaggedSexpr(x, y)))
+  | TaggedSexpr (x, y) -> Const(Sexpr (TaggedSexpr (x,y)))
+  | _ ->  raise X_syntax_error
+
+and recAnd = function
+| Nil -> Bool(true)
+| Pair(x,Nil) ->  x
+| Pair(x,y) ->  Pair(Symbol("if"),Pair(x,Pair((recAnd y),Pair(Bool(false),Nil))))
+| _ -> raise X_syntax_error
+and _parseVar_ = function
+  | Symbol(x) ->
+  (if (List.exists (fun a-> a=x) reserved_word_list) then raise X_syntax_error
+  else Var x)
+  | _ -> raise X_syntax_error
+
+and mit_def sym params body = 
+Pair(Symbol("define"),Pair(Symbol(sym),Pair(Pair(Symbol("lambda"),Pair(params,body)),Nil))) 
+
+and _propList_ = function
+ |  Nil-> true
+ |  Pair(x,y)-> _propList_(y)
+ | _ -> false
+
+and _lambda_ = function
+ | Pair(Symbol("lambda"), Pair (x,y)) -> 
+  (if (_propList_ x) then 
+  let args= List.map (_removeSymbol_) (_schemeToOcamlList_ x) in
+  let body = _seq_ (_schemeToOcamlList_ y)  in
+  if body= Const(Void) || (dup_exist args) then raise X_syntax_error
+  else
+  LambdaSimple (args, body)
+  else
+  let args= List.map (_removeSymbol_) (_schemeToOcamlList_ x) in
+  let arg= (List.hd (List.rev args)) in
+  let args= (List.rev(List.tl  (List.rev args))) in
+  let body = _seq_ (_schemeToOcamlList_ y)  in
+  if body= Const(Void) || (dup_exist args) then raise X_syntax_error
+  else
+  LambdaOpt (args,arg, body))
+  | _ ->raise X_syntax_error
+
+and dup_exist = function
+| [] ->false
+| hd::tl -> List.exists ((=) hd) tl || dup_exist tl
+
+and _schemeToOcamlList_ = function
+ | Pair(x,y)-> x:: (_schemeToOcamlList_ y)
+ | Nil -> []
+ | x -> [x]
+ 
+and _removeSymbol_ = function
+ | Symbol(a)-> a
+ | _->raise X_syntax_error
+ 
+and _quasiQuote_ = function
+  | Nil -> Nil
+  | Pair(Symbol("unquote"), Pair(a,Nil)) -> a
+  | Pair(Symbol("unquote-splicing"), Pair(a,Nil)) -> a
+  | Pair(Pair(Symbol("unquote"),Pair(a,Nil)), b) -> Pair (Symbol ("cons") , Pair ( a ,Pair((_quasiQuote_ b),Nil)))
+  | Pair(Pair(Symbol("unquote"),a), b) -> Pair (Symbol ("cons") , Pair ( a ,Pair ((_quasiQuote_ b),Nil)))
+  | Pair(Pair(Symbol("unquote-splicing"),Pair(a,Nil)), b) -> Pair (Symbol ("append") , Pair ( a ,Pair((_quasiQuote_ b),Nil)))
+  | Pair(Pair(Symbol("unquote-splicing"),a), b) -> Pair (Symbol ("append") , Pair ( a , Pair ((_quasiQuote_ b),Nil)))
+  | Pair(Pair(a, b),c) ->  Pair(Symbol "cons", Pair(Pair (Symbol "cons", Pair(_quasiQuote_ a, Pair(_quasiQuote_ b , Nil))), Pair((_quasiQuote_ c), Nil)))
+  | Pair(a, b) ->  Pair(Symbol "cons", Pair(Pair (Symbol "quote", Pair( a, Nil)), Pair((_quasiQuote_ b),Nil)))
+  | a-> (Pair (Symbol "quote", Pair( a, Nil)))
+
+and _let_ = function
+ | Pair (Nil, y)-> Applic (tag_parse (Pair(Symbol ("lambda") ,Pair(Nil,y))),[])
+ | Pair (x, y)-> Applic (tag_parse (Pair(Symbol ("lambda") ,Pair(_splitHead_ x,y))), List.map (fun a-> (tag_parse a)) (_schemeToOcamlList_ (_splitTail_ x)))
+ | _ -> raise X_syntax_error 
+
+and _letStar_ = function
+ | Pair (Nil, y)-> (Pair(Symbol ("let") ,Pair(Nil,y)))
+ | Pair (Pair(Pair(a,b),Nil), y)-> (Pair(Symbol ("let") ,Pair(Pair(Pair(a,b),Nil),y)))
+ | Pair (Pair(Pair(a,b),c),y) -> 
+ let nt= Pair(c, y) in   
+ (Pair(Symbol ("let") ,Pair(Pair(Pair(a,b),Nil),(Pair (_letStar_ nt,Nil)))))
+ | _ -> raise X_syntax_error 
+
+ and _letRec_ = function
+ | Pair (Nil, y)-> (Pair(Symbol ("let") ,Pair(Nil,y)))
+ | Pair (x, y)-> 
+ let _args_= _splitHeadRec_ x in
+ let _body_ = _splitTailRec_ x y in
+  Pair(Symbol ("let") ,Pair(_args_,_body_))
+ | _ -> raise X_syntax_error 
+
+and _seq_ x = 
+ match (List.length x) with
+ | 0 ->  Const(Void)
+ | 1 ->  tag_parse (List.hd x)
+ | _ ->  Seq (List.map (fun a-> (tag_parse a)) x)
+ 
+and _splitHead_ = function
+ | Nil -> Nil
+ | Pair(Pair(a,b),c) -> Pair(a,_splitHead_ c)
+ | _ -> raise X_syntax_error
+
+ and _splitTail_ = function
+ | Nil -> Nil
+ | Pair(Pair(a,Pair(b,Nil)),c) -> Pair(b,_splitTail_ c)
+ | _ -> raise X_syntax_error 
+ 
+
+
+
+and condrec = function
+| Nil -> Nil
+| Pair(first,rest) ->
+  (match first,rest with
+    | Pair(Symbol("else"),dothen), _ -> Pair(Symbol("begin"),dothen)
+    |Pair(test,Pair(Symbol("=>"),dothen)) , Nil -> Pair (Symbol "let",                                                                                                                             
+    Pair                                                                                                                                           
+      (Pair (Pair (Symbol "value",Pair(test,Nil)),
+      Pair
+      (Pair (Symbol "f",
+         Pair (Pair (Symbol "lambda", Pair (Nil,dothen)), Nil)),Nil)),
+    Pair
+    (Pair (Symbol "if",
+       Pair (Symbol "value",
+        Pair (Pair (Pair (Symbol "f", Nil), Pair (Symbol "value", Nil)),Nil))),Nil)))
+    
+
+    
+    |Pair(test,Pair(Symbol("=>"),dothen)) , _-> Pair (Symbol "let",                                                                                                                             
+    Pair                                                                                                                                           
+      (Pair (Pair (Symbol "value",Pair(test,Nil)),
+      Pair
+      (Pair (Symbol "f",
+         Pair (Pair (Symbol "lambda", Pair (Nil,dothen)), Nil)),
+      Pair
+        (Pair (Symbol "rest",
+          Pair (Pair (Symbol "lambda", Pair (Nil, Pair((condrec rest),Nil))), Nil)),
+        Nil))),
+    Pair
+    (Pair (Symbol "if",
+       Pair (Symbol "value",
+        Pair (Pair (Pair (Symbol "f", Nil), Pair (Symbol "value", Nil)),
+        Pair (Pair (Symbol "rest", Nil), Nil)))),
+    Nil)))
   
-end;; (* struct Tag_Parser *)
+
+  | Pair(test,dothen), Nil -> Pair(Symbol("if"),Pair(test,Pair(Pair(Symbol("begin"),dothen),Nil)))
+  | Pair(test,dothen), _ -> Pair(Symbol("if"),Pair(test,Pair(Pair(Symbol("begin"),dothen),Pair(condrec rest,Nil))))
+  | _ -> Nil)
+  | _ -> Nil
+
+
+ and _splitHeadRec_ = function
+ | Nil -> Nil
+ | Pair(Pair(a,b),c) -> Pair(Pair(a,Pair(Pair(Symbol "quote",Pair(Symbol "whatever", Nil)),Nil)),_splitHeadRec_ c)
+ | _ -> raise X_syntax_error
+ 
+and _splitTailRec_ x y = 
+ match x with
+ | Nil -> y
+ | Pair(Pair(a,Pair(b,Nil)),c) -> Pair(Pair(Symbol "set!", Pair(a, Pair(b,Nil))),(_splitTailRec_ c y))
+ | _ -> raise X_syntax_error ;;
+
+
+ 
+                              
+
+let tag_parse_expression sexpr = tag_parse sexpr;;
+let tag_parse_expressions sexpr = List.map tag_parse sexpr;;
+end;; 
