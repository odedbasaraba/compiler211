;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 50

section .data
const_tbl:
MAKE_VOID
MAKE_NIL
MAKE_LITERAL_BOOL (0)
MAKE_LITERAL_BOOL (1)
MAKE_LITERAL_STRING {119,104,97,116,101,118,101,114} 
MAKE_LITERAL_SYMBOL(const_tbl+6)
MAKE_LITERAL_RATIONAL(1, 1)  ;32
MAKE_LITERAL_CHAR(0)
MAKE_LITERAL_RATIONAL(0, 1)  ;51
MAKE_LITERAL_RATIONAL(-1, 1)  ;68

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push SOB_NIL_ADDRESS  ; oded and raviv addition, the magic argument for the dummy frame as well 
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov [fvar_tbl+24], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+32], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+40], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+48], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+56], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+64], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+72], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov [fvar_tbl+80], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov [fvar_tbl+88], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+96], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+104], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov [fvar_tbl+112], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+120], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov [fvar_tbl+128], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+136], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov [fvar_tbl+144], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+152], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+160], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+168], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+176], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+184], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+192], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+200], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+208], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+216], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+224], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov [fvar_tbl+0], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov [fvar_tbl+8], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov [fvar_tbl+232], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
mov [fvar_tbl+240], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
mov [fvar_tbl+248], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
mov [fvar_tbl+256], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+256]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+232]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+8]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+0]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+56]
;finishing working on VarFree
push rax
mov rbx, 5
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty1
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode1)
  jmp after_closure1
  not_empty1:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy1:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy1
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy1
finish_env_copy1:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args1
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args1
allocate_args1:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args1:
  cmp rcx,rbx
  je finish_copy_args1

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args1
finish_copy_args1:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode1)

  after_closure1:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont1
Lcode1:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 3)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 3)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 4)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 4)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+23 
;finishing working on const
push rax 
 
                          
;working on const
mov rax, const_tbl+23 
;finishing working on const
push rax 
 
                          
mov rbx, 2
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 1
  cmp rbx,0
  jne not_empty3
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode3)
  jmp after_closure3
  not_empty3:
  MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy3:
  mov rsi,1
  dec rsi
  cmp rcx, rsi
je finish_env_copy3
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy3
finish_env_copy3:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args3
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args3
allocate_args3:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args3:
  cmp rcx,rbx
  je finish_copy_args3

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args3
finish_copy_args3:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode3)

  after_closure3:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont3
Lcode3:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on BoxSet
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty4
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode4)
  jmp after_closure4
  not_empty4:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy4:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy4
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy4
finish_env_copy4:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args4
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args4
allocate_args4:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args4:
  cmp rcx,rbx
  je finish_copy_args4

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args4
finish_copy_args4:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode4)

  after_closure4:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont4
Lcode4:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good12
                                  mov rax,60
                                  syscall
                                  good12:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good11
                                  mov rax,60
                                  syscall
                                  good11:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse5
;working on const
mov rax, const_tbl+1 
;finishing working on const
jmp Lexit5
Lelse5:
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good8
                                  mov rax,60
                                  syscall
                                  good8:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good7
                                  mov rax,60
                                  syscall
                                  good7:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good10
                                  mov rax,60
                                  syscall
                                  good10:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 4]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good9
                                  mov rax,60
                                  syscall
                                  good9:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 3]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop6:
                                  cmp rdx,0
                                  je copy_env_and_ret_address6
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop6

                                  copy_env_and_ret_address6:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
Lexit5:
;finishing working on if
;finishing working on seq

leave
    ret
    Lcont4:
;finishing working on LambdaSimple
push rax
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;finishing working on BoxSet

;working on BoxSet
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty13
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode13)
  jmp after_closure13
  not_empty13:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy13:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy13
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy13
finish_env_copy13:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args13
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args13
allocate_args13:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args13:
  cmp rcx,rbx
  je finish_copy_args13

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args13
finish_copy_args13:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode13)

  after_closure13:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont13
Lcode13:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good20
                                  mov rax,60
                                  syscall
                                  good20:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse14
;working on const
mov rax, const_tbl+1 
;finishing working on const
jmp Lexit14
Lelse14:
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good17
                                  mov rax,60
                                  syscall
                                  good17:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good16
                                  mov rax,60
                                  syscall
                                  good16:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good19
                                  mov rax,60
                                  syscall
                                  good19:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good18
                                  mov rax,60
                                  syscall
                                  good18:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 3]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop15:
                                  cmp rdx,0
                                  je copy_env_and_ret_address15
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop15

                                  copy_env_and_ret_address15:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
Lexit14:
;finishing working on if
;finishing working on seq

leave
    ret
    Lcont13:
;finishing working on LambdaSimple
push rax
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;finishing working on BoxSet

;working on ApplicTP
push SOB_NIL_ADDRESS 

mov rbx, 0
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty22
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode22)
  jmp after_closure22
  not_empty22:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy22:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy22
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy22
finish_env_copy22:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args22
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args22
allocate_args22:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args22:
  cmp rcx,rbx
  je finish_copy_args22

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args22
finish_copy_args22:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode22)

  after_closure22:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont22
Lcode22:
    push rbp
    mov rbp,rsp 
;working on LambdaOPT
push rbx
      push rcx
      push rdx
      push rsi
      mov rbx, 3
      cmp rbx,0
      jne not_empty23
      mov rbx, SOB_NIL_ADDRESS
      MAKE_CLOSURE(rax, rbx, Lcode23)
      jmp after_closure23
      not_empty23:
      MALLOC rax, WORD_SIZE*3; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
      mov rcx,0 
      env_copy23:
      mov rsi,3
      dec rsi
      cmp rcx, rsi
je finish_env_copy23
mov rdx, [rbx + rcx * WORD_SIZE]
      inc rcx
      mov [rax + rcx * WORD_SIZE], rdx
      jmp env_copy23
finish_env_copy23:
      mov rbx, [rbp + 3 * WORD_SIZE]
      inc rbx ; for the magic
      ;cmp rbx,0
      ;jne allocate_args23
;mov rdx, SOB_NIL_ADDRESS
      ;jmp finish_copy_args23
allocate_args23:
      shl rbx,3
      MALLOC rdx, rbx
      shr rbx,3
      mov rcx,0
      copy_args23:
      cmp rcx,rbx
      je finish_copy_args23

      mov rsi, PVAR(rcx)
      mov [rdx + rcx *WORD_SIZE ],rsi
      inc rcx
      jmp copy_args23
finish_copy_args23:
      mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
      mov rbx,rax
      MAKE_CLOSURE(rax, rbx, Lcode23)

      after_closure23:
      pop rsi
      pop rdx
      pop rcx
      pop rbx
      jmp Lcont23
Lcode23:
          mov rbx,1 ; num of *mandatory* args
          mov rcx,[rsp+(2*WORD_SIZE)] ; num of args that was entered 
          cmp rbx,rcx
          je continue_with_the_code23
          mov rdx,rcx 
          sub rdx,rbx ; make rdx = [x-y]
          mov rsi,1  ; it will be for the loop


        mov r12,2
        add r12 ,rcx
        shl r12,3
        add r12,rsp ;will point to head 

        mov r13,SOB_NIL_ADDRESS

        loop23:
        cmp rsi,rdx
        je after_ops23
        mov r14, [r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov r9,rcx
        add r9,3
        shift_frame_by_one r12, r15 , r9
        dec qword[rsp + (2*WORD_SIZE)]
        inc rsi
        jmp loop23


        after_ops23:
        mov r14 ,[r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov [r12], r13

    


          continue_with_the_code23:
          push rbp
          mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop24:
                                  cmp rdx,0
                                  je copy_env_and_ret_address24
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop24

                                  copy_env_and_ret_address24:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
        ret
        Lcont23:
;finishing working on LambdaOPT

leave
    ret
    Lcont22:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 0
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,0
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop21:
                                  cmp rdx,0
                                  je copy_env_and_ret_address21
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop21

                                  copy_env_and_ret_address21:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont3:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop2:
                                  cmp rdx,0
                                  je copy_env_and_ret_address2
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop2

                                  copy_env_and_ret_address2:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont1:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good0
                                  mov rax,60
                                  syscall
                                  good0:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 16], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+232]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+8]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+0]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+56]
;finishing working on VarFree
push rax
mov rbx, 4
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty26
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode26)
  jmp after_closure26
  not_empty26:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy26:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy26
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy26
finish_env_copy26:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args26
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args26
allocate_args26:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args26:
  cmp rcx,rbx
  je finish_copy_args26

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args26
finish_copy_args26:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode26)

  after_closure26:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont26
Lcode26:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 3)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 3)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+23 
;finishing working on const
push rax 
 
                          
mov rbx, 1
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 1
  cmp rbx,0
  jne not_empty28
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode28)
  jmp after_closure28
  not_empty28:
  MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy28:
  mov rsi,1
  dec rsi
  cmp rcx, rsi
je finish_env_copy28
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy28
finish_env_copy28:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args28
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args28
allocate_args28:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args28:
  cmp rcx,rbx
  je finish_copy_args28

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args28
finish_copy_args28:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode28)

  after_closure28:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont28
Lcode28:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on BoxSet
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty29
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode29)
  jmp after_closure29
  not_empty29:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy29:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy29
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy29
finish_env_copy29:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args29
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args29
allocate_args29:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args29:
  cmp rcx,rbx
  je finish_copy_args29

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args29
finish_copy_args29:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode29)

  after_closure29:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont29
Lcode29:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good35
                                  mov rax,60
                                  syscall
                                  good35:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse30
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
jmp Lexit30
Lelse30:
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good32
                                  mov rax,60
                                  syscall
                                  good32:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good34
                                  mov rax,60
                                  syscall
                                  good34:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good33
                                  mov rax,60
                                  syscall
                                  good33:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 3
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 3
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,3
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop31:
                                  cmp rdx,0
                                  je copy_env_and_ret_address31
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop31

                                  copy_env_and_ret_address31:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
Lexit30:
;finishing working on if
;finishing working on seq

leave
    ret
    Lcont29:
;finishing working on LambdaSimple
push rax
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;finishing working on BoxSet

;working on ApplicTP
push SOB_NIL_ADDRESS 

mov rbx, 0
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty37
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode37)
  jmp after_closure37
  not_empty37:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy37:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy37
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy37
finish_env_copy37:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args37
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args37
allocate_args37:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args37:
  cmp rcx,rbx
  je finish_copy_args37

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args37
finish_copy_args37:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode37)

  after_closure37:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont37
Lcode37:
    push rbp
    mov rbp,rsp 
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet

leave
    ret
    Lcont37:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 0
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,0
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop36:
                                  cmp rdx,0
                                  je copy_env_and_ret_address36
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop36

                                  copy_env_and_ret_address36:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont28:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 1
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,1
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop27:
                                  cmp rdx,0
                                  je copy_env_and_ret_address27
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop27

                                  copy_env_and_ret_address27:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont26:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good25
                                  mov rax,60
                                  syscall
                                  good25:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 264], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+232]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+8]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+0]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+56]
;finishing working on VarFree
push rax
mov rbx, 4
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty39
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode39)
  jmp after_closure39
  not_empty39:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy39:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy39
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy39
finish_env_copy39:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args39
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args39
allocate_args39:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args39:
  cmp rcx,rbx
  je finish_copy_args39

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args39
finish_copy_args39:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode39)

  after_closure39:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont39
Lcode39:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 3)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 3)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+23 
;finishing working on const
push rax 
 
                          
mov rbx, 1
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 1
  cmp rbx,0
  jne not_empty41
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode41)
  jmp after_closure41
  not_empty41:
  MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy41:
  mov rsi,1
  dec rsi
  cmp rcx, rsi
je finish_env_copy41
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy41
finish_env_copy41:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args41
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args41
allocate_args41:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args41:
  cmp rcx,rbx
  je finish_copy_args41

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args41
finish_copy_args41:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode41)

  after_closure41:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont41
Lcode41:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on BoxSet
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty42
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode42)
  jmp after_closure42
  not_empty42:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy42:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy42
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy42
finish_env_copy42:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args42
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args42
allocate_args42:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args42:
  cmp rcx,rbx
  je finish_copy_args42

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args42
finish_copy_args42:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode42)

  after_closure42:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont42
Lcode42:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good48
                                  mov rax,60
                                  syscall
                                  good48:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse43
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
jmp Lexit43
Lelse43:
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good46
                                  mov rax,60
                                  syscall
                                  good46:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 3
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good45
                                  mov rax,60
                                  syscall
                                  good45:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good47
                                  mov rax,60
                                  syscall
                                  good47:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop44:
                                  cmp rdx,0
                                  je copy_env_and_ret_address44
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop44

                                  copy_env_and_ret_address44:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
Lexit43:
;finishing working on if
;finishing working on seq

leave
    ret
    Lcont42:
;finishing working on LambdaSimple
push rax
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;finishing working on BoxSet

;working on ApplicTP
push SOB_NIL_ADDRESS 

mov rbx, 0
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty50
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode50)
  jmp after_closure50
  not_empty50:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy50:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy50
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy50
finish_env_copy50:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args50
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args50
allocate_args50:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args50:
  cmp rcx,rbx
  je finish_copy_args50

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args50
finish_copy_args50:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode50)

  after_closure50:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont50
Lcode50:
    push rbp
    mov rbp,rsp 
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet

leave
    ret
    Lcont50:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 0
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,0
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop49:
                                  cmp rdx,0
                                  je copy_env_and_ret_address49
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop49

                                  copy_env_and_ret_address49:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont41:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 1
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,1
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop40:
                                  cmp rdx,0
                                  je copy_env_and_ret_address40
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop40

                                  copy_env_and_ret_address40:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont39:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good38
                                  mov rax,60
                                  syscall
                                  good38:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 272], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+8]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+0]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+288]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+192]
;finishing working on VarFree
push rax
mov rbx, 4
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty52
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode52)
  jmp after_closure52
  not_empty52:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy52:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy52
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy52
finish_env_copy52:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args52
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args52
allocate_args52:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args52:
  cmp rcx,rbx
  je finish_copy_args52

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args52
finish_copy_args52:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode52)

  after_closure52:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont52
Lcode52:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 3)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 3)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+23 
;finishing working on const
push rax 
 
                          
mov rbx, 1
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 1
  cmp rbx,0
  jne not_empty54
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode54)
  jmp after_closure54
  not_empty54:
  MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy54:
  mov rsi,1
  dec rsi
  cmp rcx, rsi
je finish_env_copy54
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy54
finish_env_copy54:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args54
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args54
allocate_args54:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args54:
  cmp rcx,rbx
  je finish_copy_args54

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args54
finish_copy_args54:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode54)

  after_closure54:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont54
Lcode54:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on BoxSet
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty55
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode55)
  jmp after_closure55
  not_empty55:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy55:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy55
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy55
finish_env_copy55:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args55
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args55
allocate_args55:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args55:
  cmp rcx,rbx
  je finish_copy_args55

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args55
finish_copy_args55:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode55)

  after_closure55:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont55
Lcode55:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Applic
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+32 
;finishing working on const
push rax
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good61
                                  mov rax,60
                                  syscall
                                  good61:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good60
                                  mov rax,60
                                  syscall
                                  good60:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse56
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 1
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,1
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop59:
                                  cmp rdx,0
                                  je copy_env_and_ret_address59
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop59

                                  copy_env_and_ret_address59:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
jmp Lexit56
Lelse56:
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 3]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good58
                                  mov rax,60
                                  syscall
                                  good58:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 1
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,1
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop57:
                                  cmp rdx,0
                                  je copy_env_and_ret_address57
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop57

                                  copy_env_and_ret_address57:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
Lexit56:
;finishing working on if
;finishing working on seq

leave
    ret
    Lcont55:
;finishing working on LambdaSimple
push rax
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;finishing working on BoxSet

;working on ApplicTP
push SOB_NIL_ADDRESS 

mov rbx, 0
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty63
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode63)
  jmp after_closure63
  not_empty63:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy63:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy63
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy63
finish_env_copy63:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args63
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args63
allocate_args63:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args63:
  cmp rcx,rbx
  je finish_copy_args63

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args63
finish_copy_args63:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode63)

  after_closure63:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont63
Lcode63:
    push rbp
    mov rbp,rsp 
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet

leave
    ret
    Lcont63:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 0
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,0
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop62:
                                  cmp rdx,0
                                  je copy_env_and_ret_address62
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop62

                                  copy_env_and_ret_address62:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont54:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 1
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,1
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop53:
                                  cmp rdx,0
                                  je copy_env_and_ret_address53
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop53

                                  copy_env_and_ret_address53:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont52:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good51
                                  mov rax,60
                                  syscall
                                  good51:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 280], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+232]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+8]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+0]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+192]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+288]
;finishing working on VarFree
push rax
mov rbx, 5
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty65
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode65)
  jmp after_closure65
  not_empty65:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy65:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy65
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy65
finish_env_copy65:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args65
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args65
allocate_args65:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args65:
  cmp rcx,rbx
  je finish_copy_args65

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args65
finish_copy_args65:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode65)

  after_closure65:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont65
Lcode65:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 3)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 3)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 4)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 4)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+23 
;finishing working on const
push rax 
 
                          
mov rbx, 1
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 1
  cmp rbx,0
  jne not_empty67
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode67)
  jmp after_closure67
  not_empty67:
  MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy67:
  mov rsi,1
  dec rsi
  cmp rcx, rsi
je finish_env_copy67
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy67
finish_env_copy67:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args67
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args67
allocate_args67:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args67:
  cmp rcx,rbx
  je finish_copy_args67

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args67
finish_copy_args67:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode67)

  after_closure67:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont67
Lcode67:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on BoxSet
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty68
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode68)
  jmp after_closure68
  not_empty68:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy68:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy68
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy68
finish_env_copy68:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args68
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args68
allocate_args68:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args68:
  cmp rcx,rbx
  je finish_copy_args68

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args68
finish_copy_args68:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode68)

  after_closure68:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont68
Lcode68:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Applic
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+32 
;finishing working on const
push rax
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good75
                                  mov rax,60
                                  syscall
                                  good75:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good74
                                  mov rax,60
                                  syscall
                                  good74:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse69
;working on const
mov rax, const_tbl+1 
;finishing working on const
jmp Lexit69
Lelse69:
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 3]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good72
                                  mov rax,60
                                  syscall
                                  good72:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good71
                                  mov rax,60
                                  syscall
                                  good71:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good73
                                  mov rax,60
                                  syscall
                                  good73:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 4]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop70:
                                  cmp rdx,0
                                  je copy_env_and_ret_address70
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop70

                                  copy_env_and_ret_address70:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
Lexit69:
;finishing working on if
;finishing working on seq

leave
    ret
    Lcont68:
;finishing working on LambdaSimple
push rax
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;finishing working on BoxSet

;working on ApplicTP
push SOB_NIL_ADDRESS 

mov rbx, 0
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty77
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode77)
  jmp after_closure77
  not_empty77:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy77:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy77
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy77
finish_env_copy77:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args77
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args77
allocate_args77:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args77:
  cmp rcx,rbx
  je finish_copy_args77

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args77
finish_copy_args77:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode77)

  after_closure77:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont77
Lcode77:
    push rbp
    mov rbp,rsp 
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet

leave
    ret
    Lcont77:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 0
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,0
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop76:
                                  cmp rdx,0
                                  je copy_env_and_ret_address76
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop76

                                  copy_env_and_ret_address76:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont67:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 1
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,1
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop66:
                                  cmp rdx,0
                                  je copy_env_and_ret_address66
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop66

                                  copy_env_and_ret_address66:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont65:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good64
                                  mov rax,60
                                  syscall
                                  good64:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 296], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+232]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+296]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+280]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+288]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+0]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+272]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+56]
;finishing working on VarFree
push rax
mov rbx, 7
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty79
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode79)
  jmp after_closure79
  not_empty79:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy79:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy79
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy79
finish_env_copy79:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args79
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args79
allocate_args79:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args79:
  cmp rcx,rbx
  je finish_copy_args79

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args79
finish_copy_args79:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode79)

  after_closure79:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont79
Lcode79:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 3)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 3)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 4)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 4)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 5)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 5)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 6)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 6)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on LambdaOPT
push rbx
      push rcx
      push rdx
      push rsi
      mov rbx, 1
      cmp rbx,0
      jne not_empty80
      mov rbx, SOB_NIL_ADDRESS
      MAKE_CLOSURE(rax, rbx, Lcode80)
      jmp after_closure80
      not_empty80:
      MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
      mov rcx,0 
      env_copy80:
      mov rsi,1
      dec rsi
      cmp rcx, rsi
je finish_env_copy80
mov rdx, [rbx + rcx * WORD_SIZE]
      inc rcx
      mov [rax + rcx * WORD_SIZE], rdx
      jmp env_copy80
finish_env_copy80:
      mov rbx, [rbp + 3 * WORD_SIZE]
      inc rbx ; for the magic
      ;cmp rbx,0
      ;jne allocate_args80
;mov rdx, SOB_NIL_ADDRESS
      ;jmp finish_copy_args80
allocate_args80:
      shl rbx,3
      MALLOC rdx, rbx
      shr rbx,3
      mov rcx,0
      copy_args80:
      cmp rcx,rbx
      je finish_copy_args80

      mov rsi, PVAR(rcx)
      mov [rdx + rcx *WORD_SIZE ],rsi
      inc rcx
      jmp copy_args80
finish_copy_args80:
      mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
      mov rbx,rax
      MAKE_CLOSURE(rax, rbx, Lcode80)

      after_closure80:
      pop rsi
      pop rdx
      pop rcx
      pop rbx
      jmp Lcont80
Lcode80:
          mov rbx,1 ; num of *mandatory* args
          mov rcx,[rsp+(2*WORD_SIZE)] ; num of args that was entered 
          cmp rbx,rcx
          je continue_with_the_code80
          mov rdx,rcx 
          sub rdx,rbx ; make rdx = [x-y]
          mov rsi,1  ; it will be for the loop


        mov r12,2
        add r12 ,rcx
        shl r12,3
        add r12,rsp ;will point to head 

        mov r13,SOB_NIL_ADDRESS

        loop80:
        cmp rsi,rdx
        je after_ops80
        mov r14, [r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov r9,rcx
        add r9,3
        shift_frame_by_one r12, r15 , r9
        dec qword[rsp + (2*WORD_SIZE)]
        inc rsi
        jmp loop80


        after_ops80:
        mov r14 ,[r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov [r12], r13

    


          continue_with_the_code80:
          push rbp
          mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good86
                                  mov rax,60
                                  syscall
                                  good86:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse81
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
jmp Lexit81
Lelse81:
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 5]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good84
                                  mov rax,60
                                  syscall
                                  good84:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 6]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good83
                                  mov rax,60
                                  syscall
                                  good83:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 4]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good85
                                  mov rax,60
                                  syscall
                                  good85:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 6]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 3
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 3
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,3
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop82:
                                  cmp rdx,0
                                  je copy_env_and_ret_address82
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop82

                                  copy_env_and_ret_address82:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
Lexit81:
;finishing working on if
;finishing working on seq

leave
        ret
        Lcont80:
;finishing working on LambdaOPT
;finishing working on seq

leave
    ret
    Lcont79:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good78
                                  mov rax,60
                                  syscall
                                  good78:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 304], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+232]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+272]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+56]
;finishing working on VarFree
push rax
mov rbx, 3
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty88
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode88)
  jmp after_closure88
  not_empty88:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy88:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy88
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy88
finish_env_copy88:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args88
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args88
allocate_args88:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args88:
  cmp rcx,rbx
  je finish_copy_args88

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args88
finish_copy_args88:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode88)

  after_closure88:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont88
Lcode88:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on LambdaOPT
push rbx
      push rcx
      push rdx
      push rsi
      mov rbx, 1
      cmp rbx,0
      jne not_empty89
      mov rbx, SOB_NIL_ADDRESS
      MAKE_CLOSURE(rax, rbx, Lcode89)
      jmp after_closure89
      not_empty89:
      MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
      mov rcx,0 
      env_copy89:
      mov rsi,1
      dec rsi
      cmp rcx, rsi
je finish_env_copy89
mov rdx, [rbx + rcx * WORD_SIZE]
      inc rcx
      mov [rax + rcx * WORD_SIZE], rdx
      jmp env_copy89
finish_env_copy89:
      mov rbx, [rbp + 3 * WORD_SIZE]
      inc rbx ; for the magic
      ;cmp rbx,0
      ;jne allocate_args89
;mov rdx, SOB_NIL_ADDRESS
      ;jmp finish_copy_args89
allocate_args89:
      shl rbx,3
      MALLOC rdx, rbx
      shr rbx,3
      mov rcx,0
      copy_args89:
      cmp rcx,rbx
      je finish_copy_args89

      mov rsi, PVAR(rcx)
      mov [rdx + rcx *WORD_SIZE ],rsi
      inc rcx
      jmp copy_args89
finish_copy_args89:
      mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
      mov rbx,rax
      MAKE_CLOSURE(rax, rbx, Lcode89)

      after_closure89:
      pop rsi
      pop rdx
      pop rcx
      pop rbx
      jmp Lcont89
Lcode89:
          mov rbx,0 ; num of *mandatory* args
          mov rcx,[rsp+(2*WORD_SIZE)] ; num of args that was entered 
          cmp rbx,rcx
          je continue_with_the_code89
          mov rdx,rcx 
          sub rdx,rbx ; make rdx = [x-y]
          mov rsi,1  ; it will be for the loop


        mov r12,2
        add r12 ,rcx
        shl r12,3
        add r12,rsp ;will point to head 

        mov r13,SOB_NIL_ADDRESS

        loop89:
        cmp rsi,rdx
        je after_ops89
        mov r14, [r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov r9,rcx
        add r9,3
        shift_frame_by_one r12, r15 , r9
        dec qword[rsp + (2*WORD_SIZE)]
        inc rsi
        jmp loop89


        after_ops89:
        mov r14 ,[r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov [r12], r13

    


          continue_with_the_code89:
          push rbp
          mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
;working on const
mov rax, const_tbl+1 
;finishing working on const
push rax 
 
                          
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty91
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode91)
  jmp after_closure91
  not_empty91:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy91:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy91
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy91
finish_env_copy91:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args91
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args91
allocate_args91:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args91:
  cmp rcx,rbx
  je finish_copy_args91

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args91
finish_copy_args91:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode91)

  after_closure91:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont91
Lcode91:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good94
                                  mov rax,60
                                  syscall
                                  good94:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse92
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
jmp Lexit92
Lelse92:
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 3
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 3
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,3
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop93:
                                  cmp rdx,0
                                  je copy_env_and_ret_address93
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop93

                                  copy_env_and_ret_address93:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
Lexit92:
;finishing working on if
;finishing working on seq

leave
    ret
    Lcont91:
;finishing working on LambdaSimple
push rax 
 
                          
mov rbx, 3
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 3
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,3
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop90:
                                  cmp rdx,0
                                  je copy_env_and_ret_address90
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop90

                                  copy_env_and_ret_address90:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
        ret
        Lcont89:
;finishing working on LambdaOPT
;finishing working on seq

leave
    ret
    Lcont88:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good87
                                  mov rax,60
                                  syscall
                                  good87:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 312], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on LambdaOPT
push rbx
      push rcx
      push rdx
      push rsi
      mov rbx, 0
      cmp rbx,0
      jne not_empty95
      mov rbx, SOB_NIL_ADDRESS
      MAKE_CLOSURE(rax, rbx, Lcode95)
      jmp after_closure95
      not_empty95:
      MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
      mov rcx,0 
      env_copy95:
      mov rsi,0
      dec rsi
      cmp rcx, rsi
je finish_env_copy95
mov rdx, [rbx + rcx * WORD_SIZE]
      inc rcx
      mov [rax + rcx * WORD_SIZE], rdx
      jmp env_copy95
finish_env_copy95:
      mov rbx, [rbp + 3 * WORD_SIZE]
      inc rbx ; for the magic
      ;cmp rbx,0
      ;jne allocate_args95
;mov rdx, SOB_NIL_ADDRESS
      ;jmp finish_copy_args95
allocate_args95:
      shl rbx,3
      MALLOC rdx, rbx
      shr rbx,3
      mov rcx,0
      copy_args95:
      cmp rcx,rbx
      je finish_copy_args95

      mov rsi, PVAR(rcx)
      mov [rdx + rcx *WORD_SIZE ],rsi
      inc rcx
      jmp copy_args95
finish_copy_args95:
      mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
      mov rbx,rax
      MAKE_CLOSURE(rax, rbx, Lcode95)

      after_closure95:
      pop rsi
      pop rdx
      pop rcx
      pop rbx
      jmp Lcont95
Lcode95:
          mov rbx,0 ; num of *mandatory* args
          mov rcx,[rsp+(2*WORD_SIZE)] ; num of args that was entered 
          cmp rbx,rcx
          je continue_with_the_code95
          mov rdx,rcx 
          sub rdx,rbx ; make rdx = [x-y]
          mov rsi,1  ; it will be for the loop


        mov r12,2
        add r12 ,rcx
        shl r12,3
        add r12,rsp ;will point to head 

        mov r13,SOB_NIL_ADDRESS

        loop95:
        cmp rsi,rdx
        je after_ops95
        mov r14, [r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov r9,rcx
        add r9,3
        shift_frame_by_one r12, r15 , r9
        dec qword[rsp + (2*WORD_SIZE)]
        inc rsi
        jmp loop95


        after_ops95:
        mov r14 ,[r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov [r12], r13

    


          continue_with_the_code95:
          push rbp
          mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
;finishing working on seq

leave
        ret
        Lcont95:
;finishing working on LambdaOPT
mov qword [fvar_tbl + 320], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+8]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+48]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+56]
;finishing working on VarFree
push rax
mov rbx, 3
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty97
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode97)
  jmp after_closure97
  not_empty97:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy97:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy97
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy97
finish_env_copy97:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args97
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args97
allocate_args97:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args97:
  cmp rcx,rbx
  je finish_copy_args97

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args97
finish_copy_args97:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode97)

  after_closure97:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont97
Lcode97:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+23 
;finishing working on const
push rax 
 
                          
mov rbx, 1
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 1
  cmp rbx,0
  jne not_empty99
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode99)
  jmp after_closure99
  not_empty99:
  MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy99:
  mov rsi,1
  dec rsi
  cmp rcx, rsi
je finish_env_copy99
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy99
finish_env_copy99:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args99
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args99
allocate_args99:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args99:
  cmp rcx,rbx
  je finish_copy_args99

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args99
finish_copy_args99:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode99)

  after_closure99:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont99
Lcode99:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on BoxSet
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty100
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode100)
  jmp after_closure100
  not_empty100:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy100:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy100
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy100
finish_env_copy100:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args100
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args100
allocate_args100:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args100:
  cmp rcx,rbx
  je finish_copy_args100

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args100
finish_copy_args100:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode100)

  after_closure100:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont100
Lcode100:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Or
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good106
                                  mov rax,60
                                  syscall
                                  good106:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
cmp rax, SOB_FALSE_ADDRESS
jne Lexit101
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good105
                                  mov rax,60
                                  syscall
                                  good105:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse102
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good104
                                  mov rax,60
                                  syscall
                                  good104:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 1
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,1
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop103:
                                  cmp rdx,0
                                  je copy_env_and_ret_address103
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop103

                                  copy_env_and_ret_address103:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
jmp Lexit102
Lelse102:
;working on const
mov rax, const_tbl+2 
;finishing working on const
Lexit102:
;finishing working on if
Lexit101:
;finishing working on Or
;finishing working on seq

leave
    ret
    Lcont100:
;finishing working on LambdaSimple
push rax
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;finishing working on BoxSet

;working on ApplicTP
push SOB_NIL_ADDRESS 

mov rbx, 0
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty108
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode108)
  jmp after_closure108
  not_empty108:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy108:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy108
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy108
finish_env_copy108:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args108
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args108
allocate_args108:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args108:
  cmp rcx,rbx
  je finish_copy_args108

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args108
finish_copy_args108:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode108)

  after_closure108:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont108
Lcode108:
    push rbp
    mov rbp,rsp 
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet

leave
    ret
    Lcont108:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 0
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,0
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop107:
                                  cmp rdx,0
                                  je copy_env_and_ret_address107
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop107

                                  copy_env_and_ret_address107:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont99:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 1
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,1
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop98:
                                  cmp rdx,0
                                  je copy_env_and_ret_address98
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop98

                                  copy_env_and_ret_address98:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont97:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good96
                                  mov rax,60
                                  syscall
                                  good96:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 328], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+120]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+0]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+56]
;finishing working on VarFree
push rax
mov rbx, 3
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty110
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode110)
  jmp after_closure110
  not_empty110:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy110:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy110
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy110
finish_env_copy110:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args110
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args110
allocate_args110:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args110:
  cmp rcx,rbx
  je finish_copy_args110

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args110
finish_copy_args110:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode110)

  after_closure110:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont110
Lcode110:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on LambdaOPT
push rbx
      push rcx
      push rdx
      push rsi
      mov rbx, 1
      cmp rbx,0
      jne not_empty111
      mov rbx, SOB_NIL_ADDRESS
      MAKE_CLOSURE(rax, rbx, Lcode111)
      jmp after_closure111
      not_empty111:
      MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
      mov rcx,0 
      env_copy111:
      mov rsi,1
      dec rsi
      cmp rcx, rsi
je finish_env_copy111
mov rdx, [rbx + rcx * WORD_SIZE]
      inc rcx
      mov [rax + rcx * WORD_SIZE], rdx
      jmp env_copy111
finish_env_copy111:
      mov rbx, [rbp + 3 * WORD_SIZE]
      inc rbx ; for the magic
      ;cmp rbx,0
      ;jne allocate_args111
;mov rdx, SOB_NIL_ADDRESS
      ;jmp finish_copy_args111
allocate_args111:
      shl rbx,3
      MALLOC rdx, rbx
      shr rbx,3
      mov rcx,0
      copy_args111:
      cmp rcx,rbx
      je finish_copy_args111

      mov rsi, PVAR(rcx)
      mov [rdx + rcx *WORD_SIZE ],rsi
      inc rcx
      jmp copy_args111
finish_copy_args111:
      mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
      mov rbx,rax
      MAKE_CLOSURE(rax, rbx, Lcode111)

      after_closure111:
      pop rsi
      pop rdx
      pop rcx
      pop rbx
      jmp Lcont111
Lcode111:
          mov rbx,1 ; num of *mandatory* args
          mov rcx,[rsp+(2*WORD_SIZE)] ; num of args that was entered 
          cmp rbx,rcx
          je continue_with_the_code111
          mov rdx,rcx 
          sub rdx,rbx ; make rdx = [x-y]
          mov rsi,1  ; it will be for the loop


        mov r12,2
        add r12 ,rcx
        shl r12,3
        add r12,rsp ;will point to head 

        mov r13,SOB_NIL_ADDRESS

        loop111:
        cmp rsi,rdx
        je after_ops111
        mov r14, [r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov r9,rcx
        add r9,3
        shift_frame_by_one r12, r15 , r9
        dec qword[rsp + (2*WORD_SIZE)]
        inc rsi
        jmp loop111


        after_ops111:
        mov r14 ,[r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov [r12], r13

    


          continue_with_the_code111:
          push rbp
          mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good116
                                  mov rax,60
                                  syscall
                                  good116:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse112
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+49 
;finishing working on const
push rax 
 
                          
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop115:
                                  cmp rdx,0
                                  je copy_env_and_ret_address115
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop115

                                  copy_env_and_ret_address115:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
jmp Lexit112
Lelse112:
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good114
                                  mov rax,60
                                  syscall
                                  good114:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop113:
                                  cmp rdx,0
                                  je copy_env_and_ret_address113
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop113

                                  copy_env_and_ret_address113:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
Lexit112:
;finishing working on if
;finishing working on seq

leave
        ret
        Lcont111:
;finishing working on LambdaOPT
;finishing working on seq

leave
    ret
    Lcont110:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good109
                                  mov rax,60
                                  syscall
                                  good109:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 120], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty117
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode117)
  jmp after_closure117
  not_empty117:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy117:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy117
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy117
finish_env_copy117:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args117
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args117
allocate_args117:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args117:
  cmp rcx,rbx
  je finish_copy_args117

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args117
finish_copy_args117:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode117)

  after_closure117:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont117
Lcode117:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse118
;working on const
mov rax, const_tbl+2 
;finishing working on const
jmp Lexit118
Lelse118:
;working on const
mov rax, const_tbl+4 
;finishing working on const
Lexit118:
;finishing working on if
;finishing working on seq

leave
    ret
    Lcont117:
;finishing working on LambdaSimple
mov qword [fvar_tbl + 336], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+56]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+8]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+0]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+200]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+192]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+184]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+176]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+168]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+16]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+264]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+152]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+40]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+32]
;finishing working on VarFree
push rax
mov rbx, 13
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty120
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode120)
  jmp after_closure120
  not_empty120:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy120:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy120
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy120
finish_env_copy120:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args120
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args120
allocate_args120:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args120:
  cmp rcx,rbx
  je finish_copy_args120

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args120
finish_copy_args120:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode120)

  after_closure120:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont120
Lcode120:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 3)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 3)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 4)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 4)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 5)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 5)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 6)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 6)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 7)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 7)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 8)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 8)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 9)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 9)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 10)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 10)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 11)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 11)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 12)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 12)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 1
  cmp rbx,0
  jne not_empty122
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode122)
  jmp after_closure122
  not_empty122:
  MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy122:
  mov rsi,1
  dec rsi
  cmp rcx, rsi
je finish_env_copy122
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy122
finish_env_copy122:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args122
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args122
allocate_args122:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args122:
  cmp rcx,rbx
  je finish_copy_args122

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args122
finish_copy_args122:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode122)

  after_closure122:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont122
Lcode122:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty123
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode123)
  jmp after_closure123
  not_empty123:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy123:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy123
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy123
finish_env_copy123:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args123
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args123
allocate_args123:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args123:
  cmp rcx,rbx
  je finish_copy_args123

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args123
finish_copy_args123:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode123)

  after_closure123:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont123
Lcode123:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good136
                                  mov rax,60
                                  syscall
                                  good136:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse134
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good135
                                  mov rax,60
                                  syscall
                                  good135:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
jmp Lexit134
Lelse134:
;working on const
mov rax, const_tbl+2 
;finishing working on const
Lexit134:
;finishing working on if
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse124
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good133
                                  mov rax,60
                                  syscall
                                  good133:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop132:
                                  cmp rdx,0
                                  je copy_env_and_ret_address132
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop132

                                  copy_env_and_ret_address132:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
jmp Lexit124
Lelse124:
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good131
                                  mov rax,60
                                  syscall
                                  good131:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse129
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good130
                                  mov rax,60
                                  syscall
                                  good130:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
jmp Lexit129
Lelse129:
;working on const
mov rax, const_tbl+2 
;finishing working on const
Lexit129:
;finishing working on if
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse125
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good128
                                  mov rax,60
                                  syscall
                                  good128:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop127:
                                  cmp rdx,0
                                  je copy_env_and_ret_address127
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop127

                                  copy_env_and_ret_address127:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
jmp Lexit125
Lelse125:
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop126:
                                  cmp rdx,0
                                  je copy_env_and_ret_address126
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop126

                                  copy_env_and_ret_address126:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
Lexit125:
;finishing working on if
Lexit124:
;finishing working on if
;finishing working on seq

leave
    ret
    Lcont123:
;finishing working on LambdaSimple
;finishing working on seq

leave
    ret
    Lcont122:
;finishing working on LambdaSimple
push rax 
 
                          
mov rbx, 1
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 1
  cmp rbx,0
  jne not_empty137
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode137)
  jmp after_closure137
  not_empty137:
  MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy137:
  mov rsi,1
  dec rsi
  cmp rcx, rsi
je finish_env_copy137
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy137
finish_env_copy137:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args137
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args137
allocate_args137:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args137:
  cmp rcx,rbx
  je finish_copy_args137

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args137
finish_copy_args137:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode137)

  after_closure137:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont137
Lcode137:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarFree
;working on LambdaOPT
push rbx
      push rcx
      push rdx
      push rsi
      mov rbx, 2
      cmp rbx,0
      jne not_empty138
      mov rbx, SOB_NIL_ADDRESS
      MAKE_CLOSURE(rax, rbx, Lcode138)
      jmp after_closure138
      not_empty138:
      MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
      mov rcx,0 
      env_copy138:
      mov rsi,2
      dec rsi
      cmp rcx, rsi
je finish_env_copy138
mov rdx, [rbx + rcx * WORD_SIZE]
      inc rcx
      mov [rax + rcx * WORD_SIZE], rdx
      jmp env_copy138
finish_env_copy138:
      mov rbx, [rbp + 3 * WORD_SIZE]
      inc rbx ; for the magic
      ;cmp rbx,0
      ;jne allocate_args138
;mov rdx, SOB_NIL_ADDRESS
      ;jmp finish_copy_args138
allocate_args138:
      shl rbx,3
      MALLOC rdx, rbx
      shr rbx,3
      mov rcx,0
      copy_args138:
      cmp rcx,rbx
      je finish_copy_args138

      mov rsi, PVAR(rcx)
      mov [rdx + rcx *WORD_SIZE ],rsi
      inc rcx
      jmp copy_args138
finish_copy_args138:
      mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
      mov rbx,rax
      MAKE_CLOSURE(rax, rbx, Lcode138)

      after_closure138:
      pop rsi
      pop rdx
      pop rcx
      pop rbx
      jmp Lcont138
Lcode138:
          mov rbx,0 ; num of *mandatory* args
          mov rcx,[rsp+(2*WORD_SIZE)] ; num of args that was entered 
          cmp rbx,rcx
          je continue_with_the_code138
          mov rdx,rcx 
          sub rdx,rbx ; make rdx = [x-y]
          mov rsi,1  ; it will be for the loop


        mov r12,2
        add r12 ,rcx
        shl r12,3
        add r12,rsp ;will point to head 

        mov r13,SOB_NIL_ADDRESS

        loop138:
        cmp rsi,rdx
        je after_ops138
        mov r14, [r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov r9,rcx
        add r9,3
        shift_frame_by_one r12, r15 , r9
        dec qword[rsp + (2*WORD_SIZE)]
        inc rsi
        jmp loop138


        after_ops138:
        mov r14 ,[r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov [r12], r13

    


          continue_with_the_code138:
          push rbp
          mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
;working on const
mov rax, const_tbl+51 
;finishing working on const
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 5]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good140
                                  mov rax,60
                                  syscall
                                  good140:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 3
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 3]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 3
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,3
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop139:
                                  cmp rdx,0
                                  je copy_env_and_ret_address139
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop139

                                  copy_env_and_ret_address139:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
        ret
        Lcont138:
;finishing working on LambdaOPT
mov qword [fvar_tbl + 168], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarFree

;working on Set VarFree
;working on LambdaOPT
push rbx
      push rcx
      push rdx
      push rsi
      mov rbx, 2
      cmp rbx,0
      jne not_empty141
      mov rbx, SOB_NIL_ADDRESS
      MAKE_CLOSURE(rax, rbx, Lcode141)
      jmp after_closure141
      not_empty141:
      MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
      mov rcx,0 
      env_copy141:
      mov rsi,2
      dec rsi
      cmp rcx, rsi
je finish_env_copy141
mov rdx, [rbx + rcx * WORD_SIZE]
      inc rcx
      mov [rax + rcx * WORD_SIZE], rdx
      jmp env_copy141
finish_env_copy141:
      mov rbx, [rbp + 3 * WORD_SIZE]
      inc rbx ; for the magic
      ;cmp rbx,0
      ;jne allocate_args141
;mov rdx, SOB_NIL_ADDRESS
      ;jmp finish_copy_args141
allocate_args141:
      shl rbx,3
      MALLOC rdx, rbx
      shr rbx,3
      mov rcx,0
      copy_args141:
      cmp rcx,rbx
      je finish_copy_args141

      mov rsi, PVAR(rcx)
      mov [rdx + rcx *WORD_SIZE ],rsi
      inc rcx
      jmp copy_args141
finish_copy_args141:
      mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
      mov rbx,rax
      MAKE_CLOSURE(rax, rbx, Lcode141)

      after_closure141:
      pop rsi
      pop rdx
      pop rcx
      pop rbx
      jmp Lcont141
Lcode141:
          mov rbx,0 ; num of *mandatory* args
          mov rcx,[rsp+(2*WORD_SIZE)] ; num of args that was entered 
          cmp rbx,rcx
          je continue_with_the_code141
          mov rdx,rcx 
          sub rdx,rbx ; make rdx = [x-y]
          mov rsi,1  ; it will be for the loop


        mov r12,2
        add r12 ,rcx
        shl r12,3
        add r12,rsp ;will point to head 

        mov r13,SOB_NIL_ADDRESS

        loop141:
        cmp rsi,rdx
        je after_ops141
        mov r14, [r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov r9,rcx
        add r9,3
        shift_frame_by_one r12, r15 , r9
        dec qword[rsp + (2*WORD_SIZE)]
        inc rsi
        jmp loop141


        after_ops141:
        mov r14 ,[r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov [r12], r13

    


          continue_with_the_code141:
          push rbp
          mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
;working on const
mov rax, const_tbl+32 
;finishing working on const
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 6]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good143
                                  mov rax,60
                                  syscall
                                  good143:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 3
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 3]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 3
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,3
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop142:
                                  cmp rdx,0
                                  je copy_env_and_ret_address142
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop142

                                  copy_env_and_ret_address142:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
        ret
        Lcont141:
;finishing working on LambdaOPT
mov qword [fvar_tbl + 176], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarFree

;working on Set VarFree
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 7]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good145
                                  mov rax,60
                                  syscall
                                  good145:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
mov rbx, 1
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty146
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode146)
  jmp after_closure146
  not_empty146:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy146:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy146
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy146
finish_env_copy146:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args146
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args146
allocate_args146:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args146:
  cmp rcx,rbx
  je finish_copy_args146

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args146
finish_copy_args146:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode146)

  after_closure146:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont146
Lcode146:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on LambdaOPT
push rbx
      push rcx
      push rdx
      push rsi
      mov rbx, 3
      cmp rbx,0
      jne not_empty147
      mov rbx, SOB_NIL_ADDRESS
      MAKE_CLOSURE(rax, rbx, Lcode147)
      jmp after_closure147
      not_empty147:
      MALLOC rax, WORD_SIZE*3; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
      mov rcx,0 
      env_copy147:
      mov rsi,3
      dec rsi
      cmp rcx, rsi
je finish_env_copy147
mov rdx, [rbx + rcx * WORD_SIZE]
      inc rcx
      mov [rax + rcx * WORD_SIZE], rdx
      jmp env_copy147
finish_env_copy147:
      mov rbx, [rbp + 3 * WORD_SIZE]
      inc rbx ; for the magic
      ;cmp rbx,0
      ;jne allocate_args147
;mov rdx, SOB_NIL_ADDRESS
      ;jmp finish_copy_args147
allocate_args147:
      shl rbx,3
      MALLOC rdx, rbx
      shr rbx,3
      mov rcx,0
      copy_args147:
      cmp rcx,rbx
      je finish_copy_args147

      mov rsi, PVAR(rcx)
      mov [rdx + rcx *WORD_SIZE ],rsi
      inc rcx
      jmp copy_args147
finish_copy_args147:
      mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
      mov rbx,rax
      MAKE_CLOSURE(rax, rbx, Lcode147)

      after_closure147:
      pop rsi
      pop rdx
      pop rcx
      pop rbx
      jmp Lcont147
Lcode147:
          mov rbx,1 ; num of *mandatory* args
          mov rcx,[rsp+(2*WORD_SIZE)] ; num of args that was entered 
          cmp rbx,rcx
          je continue_with_the_code147
          mov rdx,rcx 
          sub rdx,rbx ; make rdx = [x-y]
          mov rsi,1  ; it will be for the loop


        mov r12,2
        add r12 ,rcx
        shl r12,3
        add r12,rsp ;will point to head 

        mov r13,SOB_NIL_ADDRESS

        loop147:
        cmp rsi,rdx
        je after_ops147
        mov r14, [r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov r9,rcx
        add r9,3
        shift_frame_by_one r12, r15 , r9
        dec qword[rsp + (2*WORD_SIZE)]
        inc rsi
        jmp loop147


        after_ops147:
        mov r14 ,[r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov [r12], r13

    


          continue_with_the_code147:
          push rbp
          mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 12]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good151
                                  mov rax,60
                                  syscall
                                  good151:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse148
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
;working on const
mov rax, const_tbl+32 
;finishing working on const
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop150:
                                  cmp rdx,0
                                  je copy_env_and_ret_address150
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop150

                                  copy_env_and_ret_address150:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
jmp Lexit148
Lelse148:
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 3
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 3]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 3
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,3
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop149:
                                  cmp rdx,0
                                  je copy_env_and_ret_address149
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop149

                                  copy_env_and_ret_address149:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
Lexit148:
;finishing working on if
;finishing working on seq

leave
        ret
        Lcont147:
;finishing working on LambdaOPT
;finishing working on seq

leave
    ret
    Lcont146:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good144
                                  mov rax,60
                                  syscall
                                  good144:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 184], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarFree

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty153
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode153)
  jmp after_closure153
  not_empty153:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy153:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy153
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy153
finish_env_copy153:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args153
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args153
allocate_args153:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args153:
  cmp rcx,rbx
  je finish_copy_args153

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args153
finish_copy_args153:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode153)

  after_closure153:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont153
Lcode153:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+23 
;finishing working on const
push rax 
 
                          
mov rbx, 1
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 3
  cmp rbx,0
  jne not_empty155
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode155)
  jmp after_closure155
  not_empty155:
  MALLOC rax, WORD_SIZE*3; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy155:
  mov rsi,3
  dec rsi
  cmp rcx, rsi
je finish_env_copy155
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy155
finish_env_copy155:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args155
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args155
allocate_args155:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args155:
  cmp rcx,rbx
  je finish_copy_args155

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args155
finish_copy_args155:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode155)

  after_closure155:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont155
Lcode155:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on BoxSet
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 4
  cmp rbx,0
  jne not_empty156
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode156)
  jmp after_closure156
  not_empty156:
  MALLOC rax, WORD_SIZE*4; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy156:
  mov rsi,4
  dec rsi
  cmp rcx, rsi
je finish_env_copy156
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy156
finish_env_copy156:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args156
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args156
allocate_args156:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args156:
  cmp rcx,rbx
  je finish_copy_args156

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args156
finish_copy_args156:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode156)

  after_closure156:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont156
Lcode156:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Or
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 3]
mov rax, qword [rax + WORD_SIZE * 12]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good164
                                  mov rax,60
                                  syscall
                                  good164:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
cmp rax, SOB_FALSE_ADDRESS
jne Lexit157
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 3]
mov rax, qword [rax + WORD_SIZE * 10]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good163
                                  mov rax,60
                                  syscall
                                  good163:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good162
                                  mov rax,60
                                  syscall
                                  good162:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse158
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 3]
mov rax, qword [rax + WORD_SIZE * 11]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good160
                                  mov rax,60
                                  syscall
                                  good160:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 3]
mov rax, qword [rax + WORD_SIZE * 10]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good161
                                  mov rax,60
                                  syscall
                                  good161:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop159:
                                  cmp rdx,0
                                  je copy_env_and_ret_address159
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop159

                                  copy_env_and_ret_address159:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
jmp Lexit158
Lelse158:
;working on const
mov rax, const_tbl+2 
;finishing working on const
Lexit158:
;finishing working on if
Lexit157:
;finishing working on Or
;finishing working on seq

leave
    ret
    Lcont156:
;finishing working on LambdaSimple
push rax
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;finishing working on BoxSet

;working on ApplicTP
push SOB_NIL_ADDRESS 

mov rbx, 0
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 4
  cmp rbx,0
  jne not_empty166
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode166)
  jmp after_closure166
  not_empty166:
  MALLOC rax, WORD_SIZE*4; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy166:
  mov rsi,4
  dec rsi
  cmp rcx, rsi
je finish_env_copy166
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy166
finish_env_copy166:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args166
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args166
allocate_args166:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args166:
  cmp rcx,rbx
  je finish_copy_args166

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args166
finish_copy_args166:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode166)

  after_closure166:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont166
Lcode166:
    push rbp
    mov rbp,rsp 
;working on LambdaOPT
push rbx
      push rcx
      push rdx
      push rsi
      mov rbx, 5
      cmp rbx,0
      jne not_empty167
      mov rbx, SOB_NIL_ADDRESS
      MAKE_CLOSURE(rax, rbx, Lcode167)
      jmp after_closure167
      not_empty167:
      MALLOC rax, WORD_SIZE*5; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
      mov rcx,0 
      env_copy167:
      mov rsi,5
      dec rsi
      cmp rcx, rsi
je finish_env_copy167
mov rdx, [rbx + rcx * WORD_SIZE]
      inc rcx
      mov [rax + rcx * WORD_SIZE], rdx
      jmp env_copy167
finish_env_copy167:
      mov rbx, [rbp + 3 * WORD_SIZE]
      inc rbx ; for the magic
      ;cmp rbx,0
      ;jne allocate_args167
;mov rdx, SOB_NIL_ADDRESS
      ;jmp finish_copy_args167
allocate_args167:
      shl rbx,3
      MALLOC rdx, rbx
      shr rbx,3
      mov rcx,0
      copy_args167:
      cmp rcx,rbx
      je finish_copy_args167

      mov rsi, PVAR(rcx)
      mov [rdx + rcx *WORD_SIZE ],rsi
      inc rcx
      jmp copy_args167
finish_copy_args167:
      mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
      mov rbx,rax
      MAKE_CLOSURE(rax, rbx, Lcode167)

      after_closure167:
      pop rsi
      pop rdx
      pop rcx
      pop rbx
      jmp Lcont167
Lcode167:
          mov rbx,1 ; num of *mandatory* args
          mov rcx,[rsp+(2*WORD_SIZE)] ; num of args that was entered 
          cmp rbx,rcx
          je continue_with_the_code167
          mov rdx,rcx 
          sub rdx,rbx ; make rdx = [x-y]
          mov rsi,1  ; it will be for the loop


        mov r12,2
        add r12 ,rcx
        shl r12,3
        add r12,rsp ;will point to head 

        mov r13,SOB_NIL_ADDRESS

        loop167:
        cmp rsi,rdx
        je after_ops167
        mov r14, [r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov r9,rcx
        add r9,3
        shift_frame_by_one r12, r15 , r9
        dec qword[rsp + (2*WORD_SIZE)]
        inc rsi
        jmp loop167


        after_ops167:
        mov r14 ,[r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov [r12], r13

    


          continue_with_the_code167:
          push rbp
          mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop168:
                                  cmp rdx,0
                                  je copy_env_and_ret_address168
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop168

                                  copy_env_and_ret_address168:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
        ret
        Lcont167:
;finishing working on LambdaOPT

leave
    ret
    Lcont166:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 0
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,0
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop165:
                                  cmp rdx,0
                                  je copy_env_and_ret_address165
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop165

                                  copy_env_and_ret_address165:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont155:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 1
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,1
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop154:
                                  cmp rdx,0
                                  je copy_env_and_ret_address154
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop154

                                  copy_env_and_ret_address154:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont153:
;finishing working on LambdaSimple
push rax 
 
                          
mov rbx, 1
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty169
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode169)
  jmp after_closure169
  not_empty169:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy169:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy169
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy169
finish_env_copy169:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args169
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args169
allocate_args169:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args169:
  cmp rcx,rbx
  je finish_copy_args169

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args169
finish_copy_args169:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode169)

  after_closure169:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont169
Lcode169:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarFree
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 8]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good171
                                  mov rax,60
                                  syscall
                                  good171:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good170
                                  mov rax,60
                                  syscall
                                  good170:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 192], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarFree

;working on Set VarFree
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 9]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good173
                                  mov rax,60
                                  syscall
                                  good173:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good172
                                  mov rax,60
                                  syscall
                                  good172:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 200], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarFree
;finishing working on seq

leave
    ret
    Lcont169:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 1
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,1
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop152:
                                  cmp rdx,0
                                  je copy_env_and_ret_address152
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop152

                                  copy_env_and_ret_address152:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont137:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 1
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,1
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop121:
                                  cmp rdx,0
                                  je copy_env_and_ret_address121
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop121

                                  copy_env_and_ret_address121:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont120:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good119
                                  mov rax,60
                                  syscall
                                  good119:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic

	call write_sob_if_not_void

;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+56]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+168]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+256]
;finishing working on VarFree
push rax
mov rbx, 3
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty175
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode175)
  jmp after_closure175
  not_empty175:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy175:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy175
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy175
finish_env_copy175:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args175
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args175
allocate_args175:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args175:
  cmp rcx,rbx
  je finish_copy_args175

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args175
finish_copy_args175:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode175)

  after_closure175:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont175
Lcode175:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on LambdaOPT
push rbx
      push rcx
      push rdx
      push rsi
      mov rbx, 1
      cmp rbx,0
      jne not_empty176
      mov rbx, SOB_NIL_ADDRESS
      MAKE_CLOSURE(rax, rbx, Lcode176)
      jmp after_closure176
      not_empty176:
      MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
      mov rcx,0 
      env_copy176:
      mov rsi,1
      dec rsi
      cmp rcx, rsi
je finish_env_copy176
mov rdx, [rbx + rcx * WORD_SIZE]
      inc rcx
      mov [rax + rcx * WORD_SIZE], rdx
      jmp env_copy176
finish_env_copy176:
      mov rbx, [rbp + 3 * WORD_SIZE]
      inc rbx ; for the magic
      ;cmp rbx,0
      ;jne allocate_args176
;mov rdx, SOB_NIL_ADDRESS
      ;jmp finish_copy_args176
allocate_args176:
      shl rbx,3
      MALLOC rdx, rbx
      shr rbx,3
      mov rcx,0
      copy_args176:
      cmp rcx,rbx
      je finish_copy_args176

      mov rsi, PVAR(rcx)
      mov [rdx + rcx *WORD_SIZE ],rsi
      inc rcx
      jmp copy_args176
finish_copy_args176:
      mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
      mov rbx,rax
      MAKE_CLOSURE(rax, rbx, Lcode176)

      after_closure176:
      pop rsi
      pop rdx
      pop rcx
      pop rbx
      jmp Lcont176
Lcode176:
          mov rbx,1 ; num of *mandatory* args
          mov rcx,[rsp+(2*WORD_SIZE)] ; num of args that was entered 
          cmp rbx,rcx
          je continue_with_the_code176
          mov rdx,rcx 
          sub rdx,rbx ; make rdx = [x-y]
          mov rsi,1  ; it will be for the loop


        mov r12,2
        add r12 ,rcx
        shl r12,3
        add r12,rsp ;will point to head 

        mov r13,SOB_NIL_ADDRESS

        loop176:
        cmp rsi,rdx
        je after_ops176
        mov r14, [r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov r9,rcx
        add r9,3
        shift_frame_by_one r12, r15 , r9
        dec qword[rsp + (2*WORD_SIZE)]
        inc rsi
        jmp loop176


        after_ops176:
        mov r14 ,[r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov [r12], r13

    


          continue_with_the_code176:
          push rbp
          mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good183
                                  mov rax,60
                                  syscall
                                  good183:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse177
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
;working on const
mov rax, const_tbl+68 
;finishing working on const
push rax
mov rbx, 2
push rbx
;working on VarFree
mov rax, qword [fvar_tbl+176]
;finishing working on VarFree
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good182
                                  mov rax,60
                                  syscall
                                  good182:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on const
mov rax, const_tbl+51 
;finishing working on const
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop181:
                                  cmp rdx,0
                                  je copy_env_and_ret_address181
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop181

                                  copy_env_and_ret_address181:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
jmp Lexit177
Lelse177:
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good180
                                  mov rax,60
                                  syscall
                                  good180:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
;working on const
mov rax, const_tbl+68 
;finishing working on const
push rax
mov rbx, 2
push rbx
;working on VarFree
mov rax, qword [fvar_tbl+176]
;finishing working on VarFree
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good179
                                  mov rax,60
                                  syscall
                                  good179:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop178:
                                  cmp rdx,0
                                  je copy_env_and_ret_address178
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop178

                                  copy_env_and_ret_address178:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
Lexit177:
;finishing working on if
;finishing working on seq

leave
        ret
        Lcont176:
;finishing working on LambdaOPT
;finishing working on seq

leave
    ret
    Lcont175:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good174
                                  mov rax,60
                                  syscall
                                  good174:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 344], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+192]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+200]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+8]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+0]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+336]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+56]
;finishing working on VarFree
push rax
mov rbx, 6
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty185
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode185)
  jmp after_closure185
  not_empty185:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy185:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy185
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy185
finish_env_copy185:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args185
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args185
allocate_args185:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args185:
  cmp rcx,rbx
  je finish_copy_args185

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args185
finish_copy_args185:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode185)

  after_closure185:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont185
Lcode185:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 3)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 3)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 4)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 4)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 5)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 5)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+23 
;finishing working on const
push rax 
 
                          
mov rbx, 1
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 1
  cmp rbx,0
  jne not_empty187
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode187)
  jmp after_closure187
  not_empty187:
  MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy187:
  mov rsi,1
  dec rsi
  cmp rcx, rsi
je finish_env_copy187
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy187
finish_env_copy187:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args187
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args187
allocate_args187:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args187:
  cmp rcx,rbx
  je finish_copy_args187

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args187
finish_copy_args187:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode187)

  after_closure187:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont187
Lcode187:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on BoxSet
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty188
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode188)
  jmp after_closure188
  not_empty188:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy188:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy188
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy188
finish_env_copy188:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args188
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args188
allocate_args188:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args188:
  cmp rcx,rbx
  je finish_copy_args188

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args188
finish_copy_args188:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode188)

  after_closure188:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont188
Lcode188:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Or
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good201
                                  mov rax,60
                                  syscall
                                  good201:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
cmp rax, SOB_FALSE_ADDRESS
jne Lexit189
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good200
                                  mov rax,60
                                  syscall
                                  good200:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 4]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good199
                                  mov rax,60
                                  syscall
                                  good199:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good198
                                  mov rax,60
                                  syscall
                                  good198:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse190
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good197
                                  mov rax,60
                                  syscall
                                  good197:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 5]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good196
                                  mov rax,60
                                  syscall
                                  good196:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good195
                                  mov rax,60
                                  syscall
                                  good195:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse191
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 3]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good193
                                  mov rax,60
                                  syscall
                                  good193:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good194
                                  mov rax,60
                                  syscall
                                  good194:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop192:
                                  cmp rdx,0
                                  je copy_env_and_ret_address192
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop192

                                  copy_env_and_ret_address192:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
jmp Lexit191
Lelse191:
;working on const
mov rax, const_tbl+2 
;finishing working on const
Lexit191:
;finishing working on if
jmp Lexit190
Lelse190:
;working on const
mov rax, const_tbl+2 
;finishing working on const
Lexit190:
;finishing working on if
Lexit189:
;finishing working on Or
;finishing working on seq

leave
    ret
    Lcont188:
;finishing working on LambdaSimple
push rax
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;finishing working on BoxSet

;working on ApplicTP
push SOB_NIL_ADDRESS 

mov rbx, 0
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty203
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode203)
  jmp after_closure203
  not_empty203:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy203:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy203
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy203
finish_env_copy203:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args203
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args203
allocate_args203:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args203:
  cmp rcx,rbx
  je finish_copy_args203

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args203
finish_copy_args203:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode203)

  after_closure203:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont203
Lcode203:
    push rbp
    mov rbp,rsp 
;working on LambdaOPT
push rbx
      push rcx
      push rdx
      push rsi
      mov rbx, 3
      cmp rbx,0
      jne not_empty204
      mov rbx, SOB_NIL_ADDRESS
      MAKE_CLOSURE(rax, rbx, Lcode204)
      jmp after_closure204
      not_empty204:
      MALLOC rax, WORD_SIZE*3; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
      mov rcx,0 
      env_copy204:
      mov rsi,3
      dec rsi
      cmp rcx, rsi
je finish_env_copy204
mov rdx, [rbx + rcx * WORD_SIZE]
      inc rcx
      mov [rax + rcx * WORD_SIZE], rdx
      jmp env_copy204
finish_env_copy204:
      mov rbx, [rbp + 3 * WORD_SIZE]
      inc rbx ; for the magic
      ;cmp rbx,0
      ;jne allocate_args204
;mov rdx, SOB_NIL_ADDRESS
      ;jmp finish_copy_args204
allocate_args204:
      shl rbx,3
      MALLOC rdx, rbx
      shr rbx,3
      mov rcx,0
      copy_args204:
      cmp rcx,rbx
      je finish_copy_args204

      mov rsi, PVAR(rcx)
      mov [rdx + rcx *WORD_SIZE ],rsi
      inc rcx
      jmp copy_args204
finish_copy_args204:
      mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
      mov rbx,rax
      MAKE_CLOSURE(rax, rbx, Lcode204)

      after_closure204:
      pop rsi
      pop rdx
      pop rcx
      pop rbx
      jmp Lcont204
Lcode204:
          mov rbx,1 ; num of *mandatory* args
          mov rcx,[rsp+(2*WORD_SIZE)] ; num of args that was entered 
          cmp rbx,rcx
          je continue_with_the_code204
          mov rdx,rcx 
          sub rdx,rbx ; make rdx = [x-y]
          mov rsi,1  ; it will be for the loop


        mov r12,2
        add r12 ,rcx
        shl r12,3
        add r12,rsp ;will point to head 

        mov r13,SOB_NIL_ADDRESS

        loop204:
        cmp rsi,rdx
        je after_ops204
        mov r14, [r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov r9,rcx
        add r9,3
        shift_frame_by_one r12, r15 , r9
        dec qword[rsp + (2*WORD_SIZE)]
        inc rsi
        jmp loop204


        after_ops204:
        mov r14 ,[r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov [r12], r13

    


          continue_with_the_code204:
          push rbp
          mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop205:
                                  cmp rdx,0
                                  je copy_env_and_ret_address205
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop205

                                  copy_env_and_ret_address205:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
        ret
        Lcont204:
;finishing working on LambdaOPT

leave
    ret
    Lcont203:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 0
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,0
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop202:
                                  cmp rdx,0
                                  je copy_env_and_ret_address202
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop202

                                  copy_env_and_ret_address202:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont187:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 1
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,1
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop186:
                                  cmp rdx,0
                                  je copy_env_and_ret_address186
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop186

                                  copy_env_and_ret_address186:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont185:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good184
                                  mov rax,60
                                  syscall
                                  good184:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 352], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+8]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+0]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+56]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+224]
;finishing working on VarFree
push rax
mov rbx, 4
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty207
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode207)
  jmp after_closure207
  not_empty207:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy207:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy207
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy207
finish_env_copy207:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args207
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args207
allocate_args207:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args207:
  cmp rcx,rbx
  je finish_copy_args207

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args207
finish_copy_args207:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode207)

  after_closure207:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont207
Lcode207:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 3)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 3)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+23 
;finishing working on const
push rax 
 
                          
mov rbx, 1
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 1
  cmp rbx,0
  jne not_empty209
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode209)
  jmp after_closure209
  not_empty209:
  MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy209:
  mov rsi,1
  dec rsi
  cmp rcx, rsi
je finish_env_copy209
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy209
finish_env_copy209:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args209
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args209
allocate_args209:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args209:
  cmp rcx,rbx
  je finish_copy_args209

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args209
finish_copy_args209:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode209)

  after_closure209:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont209
Lcode209:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on BoxSet
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty210
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode210)
  jmp after_closure210
  not_empty210:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy210:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy210
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy210
finish_env_copy210:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args210
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args210
allocate_args210:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args210:
  cmp rcx,rbx
  je finish_copy_args210

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args210
finish_copy_args210:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode210)

  after_closure210:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont210
Lcode210:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good216
                                  mov rax,60
                                  syscall
                                  good216:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse211
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
jmp Lexit211
Lelse211:
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 3]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good213
                                  mov rax,60
                                  syscall
                                  good213:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good215
                                  mov rax,60
                                  syscall
                                  good215:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good214
                                  mov rax,60
                                  syscall
                                  good214:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop212:
                                  cmp rdx,0
                                  je copy_env_and_ret_address212
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop212

                                  copy_env_and_ret_address212:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
Lexit211:
;finishing working on if
;finishing working on seq

leave
    ret
    Lcont210:
;finishing working on LambdaSimple
push rax
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;finishing working on BoxSet

;working on ApplicTP
push SOB_NIL_ADDRESS 

mov rbx, 0
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty218
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode218)
  jmp after_closure218
  not_empty218:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy218:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy218
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy218
finish_env_copy218:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args218
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args218
allocate_args218:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args218:
  cmp rcx,rbx
  je finish_copy_args218

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args218
finish_copy_args218:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode218)

  after_closure218:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont218
Lcode218:
    push rbp
    mov rbp,rsp 
;working on LambdaOPT
push rbx
      push rcx
      push rdx
      push rsi
      mov rbx, 3
      cmp rbx,0
      jne not_empty219
      mov rbx, SOB_NIL_ADDRESS
      MAKE_CLOSURE(rax, rbx, Lcode219)
      jmp after_closure219
      not_empty219:
      MALLOC rax, WORD_SIZE*3; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
      mov rcx,0 
      env_copy219:
      mov rsi,3
      dec rsi
      cmp rcx, rsi
je finish_env_copy219
mov rdx, [rbx + rcx * WORD_SIZE]
      inc rcx
      mov [rax + rcx * WORD_SIZE], rdx
      jmp env_copy219
finish_env_copy219:
      mov rbx, [rbp + 3 * WORD_SIZE]
      inc rbx ; for the magic
      ;cmp rbx,0
      ;jne allocate_args219
;mov rdx, SOB_NIL_ADDRESS
      ;jmp finish_copy_args219
allocate_args219:
      shl rbx,3
      MALLOC rdx, rbx
      shr rbx,3
      mov rcx,0
      copy_args219:
      cmp rcx,rbx
      je finish_copy_args219

      mov rsi, PVAR(rcx)
      mov [rdx + rcx *WORD_SIZE ],rsi
      inc rcx
      jmp copy_args219
finish_copy_args219:
      mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
      mov rbx,rax
      MAKE_CLOSURE(rax, rbx, Lcode219)

      after_closure219:
      pop rsi
      pop rdx
      pop rcx
      pop rbx
      jmp Lcont219
Lcode219:
          mov rbx,0 ; num of *mandatory* args
          mov rcx,[rsp+(2*WORD_SIZE)] ; num of args that was entered 
          cmp rbx,rcx
          je continue_with_the_code219
          mov rdx,rcx 
          sub rdx,rbx ; make rdx = [x-y]
          mov rsi,1  ; it will be for the loop


        mov r12,2
        add r12 ,rcx
        shl r12,3
        add r12,rsp ;will point to head 

        mov r13,SOB_NIL_ADDRESS

        loop219:
        cmp rsi,rdx
        je after_ops219
        mov r14, [r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov r9,rcx
        add r9,3
        shift_frame_by_one r12, r15 , r9
        dec qword[rsp + (2*WORD_SIZE)]
        inc rsi
        jmp loop219


        after_ops219:
        mov r14 ,[r12]
        MAKE_PAIR(r15,r14,r13)
        mov r13,r15
        mov [r12], r13

    


          continue_with_the_code219:
          push rbp
          mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good224
                                  mov rax,60
                                  syscall
                                  good224:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse220
;working on const
mov rax, const_tbl+51 
;finishing working on const
jmp Lexit220
Lelse220:
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 3]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good222
                                  mov rax,60
                                  syscall
                                  good222:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good223
                                  mov rax,60
                                  syscall
                                  good223:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop221:
                                  cmp rdx,0
                                  je copy_env_and_ret_address221
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop221

                                  copy_env_and_ret_address221:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
Lexit220:
;finishing working on if
;finishing working on seq

leave
        ret
        Lcont219:
;finishing working on LambdaOPT

leave
    ret
    Lcont218:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 0
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,0
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop217:
                                  cmp rdx,0
                                  je copy_env_and_ret_address217
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop217

                                  copy_env_and_ret_address217:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont209:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 1
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,1
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop208:
                                  cmp rdx,0
                                  je copy_env_and_ret_address208
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop208

                                  copy_env_and_ret_address208:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont207:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good206
                                  mov rax,60
                                  syscall
                                  good206:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 224], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+192]
;finishing working on VarFree
push rax
mov rbx, 1
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty226
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode226)
  jmp after_closure226
  not_empty226:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy226:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy226
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy226
finish_env_copy226:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args226
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args226
allocate_args226:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args226:
  cmp rcx,rbx
  je finish_copy_args226

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args226
finish_copy_args226:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode226)

  after_closure226:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont226
Lcode226:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 1
  cmp rbx,0
  jne not_empty227
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode227)
  jmp after_closure227
  not_empty227:
  MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy227:
  mov rsi,1
  dec rsi
  cmp rcx, rsi
je finish_env_copy227
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy227
finish_env_copy227:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args227
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args227
allocate_args227:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args227:
  cmp rcx,rbx
  je finish_copy_args227

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args227
finish_copy_args227:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode227)

  after_closure227:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont227
Lcode227:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+51 
;finishing working on const
push rax 
 
                          
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop228:
                                  cmp rdx,0
                                  je copy_env_and_ret_address228
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop228

                                  copy_env_and_ret_address228:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont227:
;finishing working on LambdaSimple
;finishing working on seq

leave
    ret
    Lcont226:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good225
                                  mov rax,60
                                  syscall
                                  good225:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 360], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+216]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+192]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+40]
;finishing working on VarFree
push rax
mov rbx, 3
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty230
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode230)
  jmp after_closure230
  not_empty230:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy230:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy230
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy230
finish_env_copy230:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args230
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args230
allocate_args230:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args230:
  cmp rcx,rbx
  je finish_copy_args230

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args230
finish_copy_args230:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode230)

  after_closure230:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont230
Lcode230:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 1
  cmp rbx,0
  jne not_empty231
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode231)
  jmp after_closure231
  not_empty231:
  MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy231:
  mov rsi,1
  dec rsi
  cmp rcx, rsi
je finish_env_copy231
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy231
finish_env_copy231:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args231
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args231
allocate_args231:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args231:
  cmp rcx,rbx
  je finish_copy_args231

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args231
finish_copy_args231:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode231)

  after_closure231:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont231
Lcode231:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good235
                                  mov rax,60
                                  syscall
                                  good235:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse232
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+32 
;finishing working on const
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good234
                                  mov rax,60
                                  syscall
                                  good234:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop233:
                                  cmp rdx,0
                                  je copy_env_and_ret_address233
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop233

                                  copy_env_and_ret_address233:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
jmp Lexit232
Lelse232:
;working on const
mov rax, const_tbl+2 
;finishing working on const
Lexit232:
;finishing working on if
;finishing working on seq

leave
    ret
    Lcont231:
;finishing working on LambdaSimple
;finishing working on seq

leave
    ret
    Lcont230:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good229
                                  mov rax,60
                                  syscall
                                  good229:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 368], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+40]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+32]
;finishing working on VarFree
push rax
mov rbx, 2
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty237
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode237)
  jmp after_closure237
  not_empty237:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy237:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy237
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy237
finish_env_copy237:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args237
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args237
allocate_args237:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args237:
  cmp rcx,rbx
  je finish_copy_args237

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args237
finish_copy_args237:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode237)

  after_closure237:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont237
Lcode237:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 1
  cmp rbx,0
  jne not_empty238
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode238)
  jmp after_closure238
  not_empty238:
  MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy238:
  mov rsi,1
  dec rsi
  cmp rcx, rsi
je finish_env_copy238
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy238
finish_env_copy238:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args238
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args238
allocate_args238:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args238:
  cmp rcx,rbx
  je finish_copy_args238

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args238
finish_copy_args238:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode238)

  after_closure238:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont238
Lcode238:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Or
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good241
                                  mov rax,60
                                  syscall
                                  good241:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
cmp rax, SOB_FALSE_ADDRESS
jne Lexit239
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 1
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,1
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop240:
                                  cmp rdx,0
                                  je copy_env_and_ret_address240
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop240

                                  copy_env_and_ret_address240:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
Lexit239:
;finishing working on Or
;finishing working on seq

leave
    ret
    Lcont238:
;finishing working on LambdaSimple
;finishing working on seq

leave
    ret
    Lcont237:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good236
                                  mov rax,60
                                  syscall
                                  good236:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 376], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+168]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+264]
;finishing working on VarFree
push rax
mov rbx, 2
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty243
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode243)
  jmp after_closure243
  not_empty243:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy243:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy243
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy243
finish_env_copy243:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args243
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args243
allocate_args243:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args243:
  cmp rcx,rbx
  je finish_copy_args243

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args243
finish_copy_args243:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode243)

  after_closure243:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont243
Lcode243:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 1
  cmp rbx,0
  jne not_empty244
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode244)
  jmp after_closure244
  not_empty244:
  MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy244:
  mov rsi,1
  dec rsi
  cmp rcx, rsi
je finish_env_copy244
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy244
finish_env_copy244:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args244
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args244
allocate_args244:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args244:
  cmp rcx,rbx
  je finish_copy_args244

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args244
finish_copy_args244:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode244)

  after_closure244:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont244
Lcode244:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
;working on const
mov rax, const_tbl+51 
;finishing working on const
push rax 
 
                          
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty246
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode246)
  jmp after_closure246
  not_empty246:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy246:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy246
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy246
finish_env_copy246:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args246
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args246
allocate_args246:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args246:
  cmp rcx,rbx
  je finish_copy_args246

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args246
finish_copy_args246:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode246)

  after_closure246:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont246
Lcode246:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+32 
;finishing working on const
push rax 
 
                          
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop247:
                                  cmp rdx,0
                                  je copy_env_and_ret_address247
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop247

                                  copy_env_and_ret_address247:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont246:
;finishing working on LambdaSimple
push rax 
 
                          
mov rbx, 3
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 3
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,3
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop245:
                                  cmp rdx,0
                                  je copy_env_and_ret_address245
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop245

                                  copy_env_and_ret_address245:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont244:
;finishing working on LambdaSimple
;finishing working on seq

leave
    ret
    Lcont243:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good242
                                  mov rax,60
                                  syscall
                                  good242:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 288], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+232]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+344]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+200]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+96]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+104]
;finishing working on VarFree
push rax
mov rbx, 5
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty249
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode249)
  jmp after_closure249
  not_empty249:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy249:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy249
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy249
finish_env_copy249:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args249
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args249
allocate_args249:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args249:
  cmp rcx,rbx
  je finish_copy_args249

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args249
finish_copy_args249:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode249)

  after_closure249:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont249
Lcode249:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 3)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 3)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 4)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 4)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 1
  cmp rbx,0
  jne not_empty250
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode250)
  jmp after_closure250
  not_empty250:
  MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy250:
  mov rsi,1
  dec rsi
  cmp rcx, rsi
je finish_env_copy250
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy250
finish_env_copy250:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args250
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args250
allocate_args250:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args250:
  cmp rcx,rbx
  je finish_copy_args250

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args250
finish_copy_args250:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode250)

  after_closure250:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont250
Lcode250:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+23 
;finishing working on const
push rax 
 
                          
mov rbx, 1
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty252
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode252)
  jmp after_closure252
  not_empty252:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy252:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy252
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy252
finish_env_copy252:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args252
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args252
allocate_args252:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args252:
  cmp rcx,rbx
  je finish_copy_args252

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args252
finish_copy_args252:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode252)

  after_closure252:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont252
Lcode252:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on BoxSet
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 3
  cmp rbx,0
  jne not_empty253
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode253)
  jmp after_closure253
  not_empty253:
  MALLOC rax, WORD_SIZE*3; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy253:
  mov rsi,3
  dec rsi
  cmp rcx, rsi
je finish_env_copy253
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy253
finish_env_copy253:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args253
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args253
allocate_args253:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args253:
  cmp rcx,rbx
  je finish_copy_args253

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args253
finish_copy_args253:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode253)

  after_closure253:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont253
Lcode253:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Applic
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+51 
;finishing working on const
push rax
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good259
                                  mov rax,60
                                  syscall
                                  good259:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse254
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
jmp Lexit254
Lelse254:
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good257
                                  mov rax,60
                                  syscall
                                  good257:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 4]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good256
                                  mov rax,60
                                  syscall
                                  good256:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+32 
;finishing working on const
push rax
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 3]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good258
                                  mov rax,60
                                  syscall
                                  good258:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop255:
                                  cmp rdx,0
                                  je copy_env_and_ret_address255
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop255

                                  copy_env_and_ret_address255:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
Lexit254:
;finishing working on if
;finishing working on seq

leave
    ret
    Lcont253:
;finishing working on LambdaSimple
push rax
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;finishing working on BoxSet

;working on ApplicTP
push SOB_NIL_ADDRESS 

mov rbx, 0
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 3
  cmp rbx,0
  jne not_empty261
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode261)
  jmp after_closure261
  not_empty261:
  MALLOC rax, WORD_SIZE*3; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy261:
  mov rsi,3
  dec rsi
  cmp rcx, rsi
je finish_env_copy261
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy261
finish_env_copy261:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args261
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args261
allocate_args261:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args261:
  cmp rcx,rbx
  je finish_copy_args261

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args261
finish_copy_args261:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode261)

  after_closure261:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont261
Lcode261:
    push rbp
    mov rbp,rsp 
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+1 
;finishing working on const
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+32 
;finishing working on const
push rax
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good264
                                  mov rax,60
                                  syscall
                                  good264:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 3]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good263
                                  mov rax,60
                                  syscall
                                  good263:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop262:
                                  cmp rdx,0
                                  je copy_env_and_ret_address262
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop262

                                  copy_env_and_ret_address262:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP

leave
    ret
    Lcont261:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 0
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,0
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop260:
                                  cmp rdx,0
                                  je copy_env_and_ret_address260
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop260

                                  copy_env_and_ret_address260:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont252:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 1
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,1
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop251:
                                  cmp rdx,0
                                  je copy_env_and_ret_address251
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop251

                                  copy_env_and_ret_address251:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont250:
;finishing working on LambdaSimple
;finishing working on seq

leave
    ret
    Lcont249:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good248
                                  mov rax,60
                                  syscall
                                  good248:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 384], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on Def
;working on Applic
push SOB_NIL_ADDRESS 
;working on VarFree
mov rax, qword [fvar_tbl+136]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+8]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+0]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+160]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+72]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+64]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+48]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+32]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+40]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+384]
;finishing working on VarFree
push rax
;working on VarFree
mov rax, qword [fvar_tbl+192]
;finishing working on VarFree
push rax
mov rbx, 11
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 0
  cmp rbx,0
  jne not_empty266
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode266)
  jmp after_closure266
  not_empty266:
  MALLOC rax, WORD_SIZE*0; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy266:
  mov rsi,0
  dec rsi
  cmp rcx, rsi
je finish_env_copy266
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy266
finish_env_copy266:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args266
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args266
allocate_args266:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args266:
  cmp rcx,rbx
  je finish_copy_args266

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args266
finish_copy_args266:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode266)

  after_closure266:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont266
Lcode266:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 2)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 2)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 3)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 3)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 4)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 4)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 5)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 5)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 6)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 6)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 7)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 7)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 8)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 8)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 9)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 9)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 10)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 10)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on const
mov rax, const_tbl+23 
;finishing working on const
push rax 
 
                          
mov rbx, 1
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 1
  cmp rbx,0
  jne not_empty268
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode268)
  jmp after_closure268
  not_empty268:
  MALLOC rax, WORD_SIZE*1; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy268:
  mov rsi,1
  dec rsi
  cmp rcx, rsi
je finish_env_copy268
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy268
finish_env_copy268:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args268
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args268
allocate_args268:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args268:
  cmp rcx,rbx
  je finish_copy_args268

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args268
finish_copy_args268:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode268)

  after_closure268:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont268
Lcode268:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on BoxSet
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty269
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode269)
  jmp after_closure269
  not_empty269:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy269:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy269
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy269
finish_env_copy269:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args269
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args269
allocate_args269:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args269:
  cmp rcx,rbx
  je finish_copy_args269

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args269
finish_copy_args269:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode269)

  after_closure269:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont269
Lcode269:
    push rbp
    mov rbp,rsp 
;working on seq
;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 0)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Set VarParam
;working on Box
MALLOC rbx, WORD_SIZE
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov qword [rbx] , rax
mov rax, rbx 
;finishing working on Box
mov qword [rbp + WORD_SIZE * (4 + 1)], rax
mov rax, SOB_VOID_ADDRESS
;finishing working on Set VarParam

;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good305
                                  mov rax,60
                                  syscall
                                  good305:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse303
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 2]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good304
                                  mov rax,60
                                  syscall
                                  good304:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
jmp Lexit303
Lelse303:
;working on const
mov rax, const_tbl+2 
;finishing working on const
Lexit303:
;finishing working on if
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse270
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop302:
                                  cmp rdx,0
                                  je copy_env_and_ret_address302
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop302

                                  copy_env_and_ret_address302:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
jmp Lexit270
Lelse270:
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 3]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good301
                                  mov rax,60
                                  syscall
                                  good301:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse299
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 3]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good300
                                  mov rax,60
                                  syscall
                                  good300:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
jmp Lexit299
Lelse299:
;working on const
mov rax, const_tbl+2 
;finishing working on const
Lexit299:
;finishing working on if
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse271
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop298:
                                  cmp rdx,0
                                  je copy_env_and_ret_address298
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop298

                                  copy_env_and_ret_address298:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
jmp Lexit271
Lelse271:
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 5]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good297
                                  mov rax,60
                                  syscall
                                  good297:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse295
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 5]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good296
                                  mov rax,60
                                  syscall
                                  good296:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
jmp Lexit295
Lelse295:
;working on const
mov rax, const_tbl+2 
;finishing working on const
Lexit295:
;finishing working on if
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse272
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 10]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good293
                                  mov rax,60
                                  syscall
                                  good293:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 10]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good294
                                  mov rax,60
                                  syscall
                                  good294:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop292:
                                  cmp rdx,0
                                  je copy_env_and_ret_address292
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop292

                                  copy_env_and_ret_address292:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
jmp Lexit272
Lelse272:
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 4]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good291
                                  mov rax,60
                                  syscall
                                  good291:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse289
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 4]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good290
                                  mov rax,60
                                  syscall
                                  good290:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
jmp Lexit289
Lelse289:
;working on const
mov rax, const_tbl+2 
;finishing working on const
Lexit289:
;finishing working on if
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse273
;working on Applic
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 8]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good287
                                  mov rax,60
                                  syscall
                                  good287:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 8]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good288
                                  mov rax,60
                                  syscall
                                  good288:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good286
                                  mov rax,60
                                  syscall
                                  good286:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse282
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 9]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good284
                                  mov rax,60
                                  syscall
                                  good284:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 9]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good285
                                  mov rax,60
                                  syscall
                                  good285:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop283:
                                  cmp rdx,0
                                  je copy_env_and_ret_address283
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop283

                                  copy_env_and_ret_address283:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
jmp Lexit282
Lelse282:
;working on const
mov rax, const_tbl+2 
;finishing working on const
Lexit282:
;finishing working on if
jmp Lexit273
Lelse273:
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 6]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good281
                                  mov rax,60
                                  syscall
                                  good281:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse279
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 6]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good280
                                  mov rax,60
                                  syscall
                                  good280:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
jmp Lexit279
Lelse279:
;working on const
mov rax, const_tbl+2 
;finishing working on const
Lexit279:
;finishing working on if
;working on if
cmp rax, SOB_FALSE_ADDRESS
je Lelse274
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good277
                                  mov rax,60
                                  syscall
                                  good277:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
;working on Applic
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax
mov rbx, 1
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 1]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good278
                                  mov rax,60
                                  syscall
                                  good278:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop276:
                                  cmp rdx,0
                                  je copy_env_and_ret_address276
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop276

                                  copy_env_and_ret_address276:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
jmp Lexit274
Lelse274:
;working on ApplicTP
push SOB_NIL_ADDRESS 
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 1)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
;working on BoxGet
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
mov rax, qword [rax]
;finishing working on BoxGet
push rax 
 
                          
mov rbx, 2
push rbx
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 1]
mov rax, qword [rax + WORD_SIZE * 7]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 2
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,2
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop275:
                                  cmp rdx,0
                                  je copy_env_and_ret_address275
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop275

                                  copy_env_and_ret_address275:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
Lexit274:
;finishing working on if
Lexit273:
;finishing working on if
Lexit272:
;finishing working on if
Lexit271:
;finishing working on if
Lexit270:
;finishing working on if
;finishing working on seq

leave
    ret
    Lcont269:
;finishing working on LambdaSimple
push rax
;working on Var param
mov rax, qword [rbp + WORD_SIZE * (4 + 0)] 
;finishing working on Var param
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;finishing working on BoxSet

;working on ApplicTP
push SOB_NIL_ADDRESS 

mov rbx, 0
push rbx
;working on LambdaSimple
push rbx
  push rcx
  push rdx
  push rsi
  mov rbx, 2
  cmp rbx,0
  jne not_empty307
  mov rbx, SOB_NIL_ADDRESS
  MAKE_CLOSURE(rax, rbx, Lcode307)
  jmp after_closure307
  not_empty307:
  MALLOC rax, WORD_SIZE*2; allocate new enviorment 
mov rbx,[rbp +2 *WORD_SIZE]
  mov rcx,0 
  env_copy307:
  mov rsi,2
  dec rsi
  cmp rcx, rsi
je finish_env_copy307
mov rdx, [rbx + rcx * WORD_SIZE]
  inc rcx
  mov [rax + rcx * WORD_SIZE], rdx
  jmp env_copy307
finish_env_copy307:

  mov rbx, [rbp + 3 * WORD_SIZE]
  inc rbx ; for the magic
  ;cmp rbx,0
  ;jne allocate_args307
;mov rdx, SOB_NIL_ADDRESS
  ;jmp finish_copy_args307
allocate_args307:
  shl rbx,3
  MALLOC rdx, rbx
  shr rbx,3
  mov rcx,0
  copy_args307:
  cmp rcx,rbx
  je finish_copy_args307

  mov rsi, PVAR(rcx)
  mov [rdx + rcx *WORD_SIZE ],rsi
  inc rcx
  jmp copy_args307
finish_copy_args307:
  mov [rax + 0 * WORD_SIZE] , rdx ;place at envorment 0
  mov rbx,rax
  MAKE_CLOSURE(rax, rbx, Lcode307)

  after_closure307:
  pop rsi
  pop rdx
  pop rcx
  pop rbx
  jmp Lcont307
Lcode307:
    push rbp
    mov rbp,rsp 
;working on BoxGet
;working on VarBound
mov rax, qword [rbp + WORD_SIZE * 2]
mov rax, qword [rax + WORD_SIZE * 0]
mov rax, qword [rax + WORD_SIZE * 0]
;finishing working on VarBound
mov rax, qword [rax]
;finishing working on BoxGet

leave
    ret
    Lcont307:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 0
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,0
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop306:
                                  cmp rdx,0
                                  je copy_env_and_ret_address306
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop306

                                  copy_env_and_ret_address306:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont268:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  push qword[rbp+(1 * WORD_SIZE)]
                                  
                                  ;put in rbx (register 1) address of top of stack to override
                                  lea rbx,[rbp + (3 * WORD_SIZE)]
                                  mov rcx,[rbx]
                                  add rcx,1 ; for the magic
                                  shl rcx,3
                                  add rbx,rcx

                                  ;put in rcx (register 2) address of top of stack that overrides
                                  mov rcx, 1
                                  add rcx,3
                                  shl rcx, 3
                                  add rcx,rsp

                                  ;put in rdx (register 3)num of new args
                                  mov rdx,1
                                  add rdx,2

                                  ;put in rsi (register 4) old rbp adress
                                  mov rsi,[rbp]

                                  copy_loop267:
                                  cmp rdx,0
                                  je copy_env_and_ret_address267
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  sub rdx,1
                                  jmp copy_loop267

                                  copy_env_and_ret_address267:
                                  push qword[rcx]
                                  pop qword[rbx]
                                  sub rbx,WORD_SIZE
                                  sub rcx,WORD_SIZE
                                  push qword[rcx]
                                  pop qword[rbx]  
                                  mov rbp,rsi
                                  mov rsp,rbx
                                  CLOSURE_CODE rbx, rax
                                  jmp rbx
                                  ;finishing working on ApplicTP
;finishing working on seq

leave
    ret
    Lcont266:
;finishing working on LambdaSimple
cmp qword[rax + (0 * WORD_SIZE)], T_CLOSURE
                                  jne good265
                                  mov rax,60
                                  syscall
                                  good265:
                                  CLOSURE_ENV rbx, rax
                                  push rbx
                                  CLOSURE_CODE rbx, rax
                                  call rbx
                                  add rsp, 8 ; delete env from stack
                                  pop rbx ; keep arg_count in rbx
                                  inc rbx ; add 1 for the magic to clean
                                  shl rbx, 3
                                  add rsp, rbx ; delete args and magic 

                                          ;                   pop rbx ; restore rbx value
;finishing working on Applic
mov qword [fvar_tbl + 392], rax 
mov rax, SOB_VOID_ADDRESS
;finishing working on Def

	call write_sob_if_not_void

;working on VarFree
mov rax, qword [fvar_tbl+168]
;finishing working on VarFree

	call write_sob_if_not_void


   ;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
   pop rbp
   add rsp, 4*8
   mov rax, 0

   ret

    apply:
    mov rbx,[rsp + (2 * WORD_SIZE)]
    mov rcx, [rsp + (3 * WORD_SIZE)]
    CLOSURE_ENV rdx , rcx
    mov [rsp + (1 * WORD_SIZE)],rdx
    mov r12, rbx
    inc r12
    shl r12 , 3
    add r12 , rsp
    mov r13,[r12 + (1 * WORD_SIZE)]
    mov rsi,2

    .apply_loop:
    cmp rsi , rbx
    je .finish
    mov r14,[r12]
    MAKE_PAIR(r15,r14,r13)
    mov r13,r15
    mov [r12 + (1 * WORD_SIZE)],r13
    mov r9,rbx
    sub r9,rsi
    add r9,3
    shift_frame_by_one r12, r15 , r9
    dec qword[rsp + (2*WORD_SIZE)]
    inc rsi
    jmp .apply_loop

    .finish:
    mov r9,3
    shift_frame_by_one r12, r15 , r9
    dec qword[rsp + (2*WORD_SIZE)]
    CLOSURE_CODE rdx,rcx
    jmp rdx
    

boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 ucomisd xmm0, xmm1
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov qword rax, [rsi+TYPE_SIZE]
         pop rbp
         ret

cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov qword rax, [rsi+TYPE_SIZE+WORD_SIZE]
         pop rbp
         ret

set_car:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov qword [rsi+TYPE_SIZE], rdi
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

set_cdr:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov qword[rsi+TYPE_SIZE+WORD_SIZE], rdi
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

cons:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	MAKE_PAIR(rax,rsi,rdi)
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	       STRING_LENGTH rcx, rsi
	       STRING_ELEMENTS rdi, rsi
	       push rcx
	       push rdi
	       mov dil, byte [rdi]
	       MAKE_CHAR(rax, dil)
	       push rax
	       MAKE_RATIONAL(rax, rcx, 1)
	       push rax
	       push 2
	       push SOB_NIL_ADDRESS
	       call make_string
	       add rsp, 4*8
	       STRING_ELEMENTS rsi, rax   
	       pop rdi
	       pop rcx
	       cmp rcx, 0
	       je .end
        .loop:
	       lea r8, [rdi+rcx]
	       lea r9, [rsi+rcx]
	       mov bl, byte [r8]
	       mov byte [r9], bl
	       loop .loop
               .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
       .loop:
	 and rdi, rdi
	 jz .end_loop
	 xor rdx, rdx 
	 div rdi
	 mov rax, rdi
	 mov rdi, rdx
	 jmp .loop	
       .end_loop:
	 mov rdx, rax
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret